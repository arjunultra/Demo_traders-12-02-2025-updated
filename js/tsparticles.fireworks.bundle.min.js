/*! For license information please see tsparticles.fireworks.bundle.min.js.LICENSE.txt */
!(function (t, e) {
  if ("object" == typeof exports && "object" == typeof module)
    module.exports = e();
  else if ("function" == typeof define && define.amd) define([], e);
  else {
    var i = e();
    for (var s in i) ("object" == typeof exports ? exports : t)[s] = i[s];
  }
})(this, () =>
  (() => {
    var t = {
        d: (e, i) => {
          for (var s in i)
            t.o(i, s) &&
              !t.o(e, s) &&
              Object.defineProperty(e, s, { enumerable: !0, get: i[s] });
        },
        o: (t, e) => Object.prototype.hasOwnProperty.call(t, e),
        r: (t) => {
          "undefined" != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
            Object.defineProperty(t, "__esModule", { value: !0 });
        },
      },
      e = {};
    t.r(e),
      t.d(e, {
        AlterType: () => di,
        AnimatableColor: () => Os,
        AnimationMode: () => Pe,
        AnimationOptions: () => zs,
        AnimationStatus: () => Ce,
        AnimationValueWithRandom: () => Rs,
        Background: () => rs,
        BackgroundMask: () => ls,
        BackgroundMaskCover: () => cs,
        BaseRange: () => po,
        Circle: () => fo,
        ClickEvent: () => ds,
        CollisionMode: () => yi,
        Collisions: () => Ls,
        CollisionsAbsorb: () => ks,
        CollisionsOverlap: () => Ss,
        ColorAnimation: () => Ps,
        DestroyType: () => Oe,
        DivEvent: () => us,
        DivType: () => fi,
        EasingType: () => Do,
        EventType: () => pi,
        Events: () => vs,
        ExternalInteractorBase: () => Co,
        FullScreen: () => hs,
        GradientType: () => So,
        HoverEvent: () => fs,
        HslAnimation: () => Cs,
        Interactivity: () => gs,
        InteractivityDetect: () => ui,
        InteractorType: () => _i,
        LimitMode: () => wi,
        ManualParticle: () => ws,
        Modes: () => ys,
        Move: () => $s,
        MoveAngle: () => As,
        MoveAttract: () => Vs,
        MoveCenter: () => Bs,
        MoveDirection: () => qt,
        MoveGravity: () => Us,
        MovePath: () => Ws,
        MoveTrail: () => qs,
        Opacity: () => Qs,
        OpacityAnimation: () => js,
        Options: () => ro,
        OptionsColor: () => as,
        OutMode: () => gi,
        OutModeDirection: () => ke,
        OutModes: () => Gs,
        Parallax: () => ps,
        ParticleOutType: () => bi,
        ParticlesBounce: () => Is,
        ParticlesBounceFactor: () => Ts,
        ParticlesDensity: () => Xs,
        ParticlesInteractorBase: () => Oo,
        ParticlesNumber: () => Zs,
        ParticlesNumberLimit: () => Ys,
        ParticlesOptions: () => oo,
        PixelMode: () => Se,
        Point: () => uo,
        RangedAnimationOptions: () => Ms,
        RangedAnimationValueWithRandom: () => Es,
        Rectangle: () => mo,
        ResizeEvent: () => ms,
        Responsive: () => _s,
        ResponsiveMode: () => mi,
        RotateDirection: () => ko,
        Shadow: () => Js,
        Shape: () => Ks,
        Size: () => eo,
        SizeAnimation: () => to,
        Spin: () => Ns,
        StartValueType: () => De,
        Stroke: () => io,
        Theme: () => xs,
        ThemeDefault: () => bs,
        ThemeMode: () => vi,
        ValueWithRandom: () => Ds,
        Vector: () => Jt,
        Vector3d: () => Zt,
        ZIndex: () => so,
        alterHsl: () => ts,
        animate: () => oe,
        areBoundsInside: () => Ne,
        arrayRandomIndex: () => He,
        calcExactPositionOrRandomFromSize: () => xe,
        calcExactPositionOrRandomFromSizeRanged: () => ze,
        calcPositionFromSize: () => we,
        calcPositionOrRandomFromSize: () => _e,
        calcPositionOrRandomFromSizeRanged: () => be,
        calculateBounds: () => $e,
        cancelAnimation: () => ne,
        canvasFirstIndex: () => at,
        canvasTag: () => k,
        circleBounce: () => Ke,
        circleBounceDataFromParticle: () => Je,
        clamp: () => ae,
        clear: () => ji,
        clickRadius: () => K,
        cloneStyle: () => li,
        collisionVelocity: () => ge,
        colorMix: () => Fi,
        colorToHsl: () => Ci,
        colorToRgb: () => Pi,
        countOffset: () => _t,
        decayOffset: () => dt,
        deepExtend: () => je,
        defaultAlpha: () => P,
        defaultAngle: () => St,
        defaultDensityFactor: () => Pt,
        defaultFps: () => M,
        defaultFpsLimit: () => ot,
        defaultLoops: () => Wt,
        defaultOpacity: () => J,
        defaultRadius: () => vt,
        defaultRatio: () => T,
        defaultReduceFactor: () => I,
        defaultRemoveQuantity: () => E,
        defaultRetryCount: () => S,
        defaultRgbMin: () => Bt,
        defaultTime: () => Ht,
        defaultTransform: () => w,
        defaultTransformValue: () => Q,
        defaultVelocity: () => Ut,
        degToRad: () => me,
        deleteCount: () => Ct,
        divMode: () => Ze,
        divModeExecute: () => Xe,
        double: () => x,
        doublePI: () => z,
        drawEffect: () => Xi,
        drawLine: () => Gi,
        drawParticle: () => Qi,
        drawParticlePlugin: () => Ki,
        drawPlugin: () => Ji,
        drawShape: () => Yi,
        drawShapeAfterDraw: () => Zi,
        empty: () => G,
        errorPrefix: () => f,
        executeOnSingleOrMultiple: () => ei,
        findItemFromSingleOrMultiple: () => si,
        fireworks: () => wa,
        generatedAttribute: () => i,
        generatedFalse: () => O,
        generatedTrue: () => C,
        getDistance: () => fe,
        getDistances: () => pe,
        getFullScreenStyle: () => hi,
        getHslAnimationFromHsl: () => Ui,
        getHslFromAnimation: () => Bi,
        getLinkColor: () => Ai,
        getLinkRandomColor: () => Vi,
        getLogger: () => Te,
        getParticleBaseVelocity: () => ye,
        getParticleDirectionAngle: () => ve,
        getPosition: () => ai,
        getRandom: () => ie,
        getRandomRgbColor: () => Ti,
        getRangeMax: () => de,
        getRangeMin: () => he,
        getRangeValue: () => le,
        getSize: () => ri,
        getStyleFromHsl: () => Li,
        getStyleFromRgb: () => Ii,
        hMax: () => V,
        hMin: () => W,
        hPhase: () => q,
        half: () => v,
        hasMatchMedia: () => Fe,
        hslToRgb: () => Ri,
        hslaToRgba: () => Ei,
        identity: () => Dt,
        initParticleNumericAnimationValue: () => oi,
        inverseFactorNumerator: () => F,
        isArray: () => Xt,
        isBoolean: () => Gt,
        isDivModeEnabled: () => Qe,
        isFunction: () => jt,
        isInArray: () => Ue,
        isNull: () => Yt,
        isNumber: () => $t,
        isObject: () => Qt,
        isPointInside: () => Ge,
        isSsr: () => Le,
        isString: () => Nt,
        itemFromArray: () => qe,
        itemFromSingleOrMultiple: () => ii,
        lFactor: () => Et,
        lMax: () => U,
        lMin: () => Tt,
        lengthOffset: () => Mt,
        loadFont: () => We,
        loadMinIndex: () => ct,
        loadOptions: () => no,
        loadParticlesOptions: () => ao,
        loadRandomFactor: () => rt,
        manualCount: () => zt,
        manualDefaultPosition: () => kt,
        midColorValue: () => b,
        millisecondsToSeconds: () => y,
        minCoordinate: () => et,
        minCount: () => bt,
        minFpsLimit: () => nt,
        minIndex: () => xt,
        minLimit: () => wt,
        minRetries: () => pt,
        minStrokeWidth: () => Rt,
        minVelocity: () => j,
        minZ: () => mt,
        minimumLength: () => Y,
        minimumSize: () => X,
        mix: () => re,
        mouseDownEvent: () => s,
        mouseLeaveEvent: () => n,
        mouseMoveEvent: () => r,
        mouseOutEvent: () => a,
        mouseUpEvent: () => o,
        none: () => ht,
        one: () => lt,
        originPoint: () => g,
        paintBase: () => Ni,
        paintImage: () => $i,
        parseAlpha: () => Me,
        percentDenominator: () => m,
        phaseNumerator: () => Vt,
        posOffset: () => yt,
        qTreeCapacity: () => R,
        quarter: () => N,
        randomColorValue: () => _,
        randomInRange: () => ce,
        rangeColorToHsl: () => Oi,
        rangeColorToRgb: () => Mi,
        rectBounce: () => ti,
        removeDeleteCount: () => it,
        removeMinIndex: () => st,
        resizeEvent: () => u,
        rgbFactor: () => It,
        rgbMax: () => A,
        rgbToHsl: () => ki,
        rollFactor: () => ft,
        sMax: () => B,
        sMin: () => H,
        sNormalizedOffset: () => At,
        safeIntersectionObserver: () => Ve,
        safeMatchMedia: () => Ae,
        safeMutationObserver: () => Be,
        setAnimationFunctions: () => se,
        setLogger: () => Ee,
        setRandom: () => ee,
        setRangeValue: () => ue,
        sextuple: () => Ft,
        singleDivModeExecute: () => Ye,
        sizeFactor: () => gt,
        squareExp: () => D,
        stringToAlpha: () => Si,
        stringToRgb: () => Di,
        subdivideCount: () => L,
        threeQuarter: () => $,
        touchCancelEvent: () => d,
        touchDelay: () => Ot,
        touchEndEvent: () => l,
        touchEndLengthOffset: () => tt,
        touchMoveEvent: () => h,
        touchStartEvent: () => c,
        triple: () => Lt,
        tryCountIncrement: () => ut,
        tsParticles: () => Ro,
        updateAnimation: () => ci,
        updateColor: () => qi,
        updateColorValue: () => Hi,
        visibilityChangeEvent: () => p,
        zIndexFactorOffset: () => Z,
      });
    const i = "generated",
      s = "pointerdown",
      o = "pointerup",
      n = "pointerleave",
      a = "pointerout",
      r = "pointermove",
      c = "touchstart",
      l = "touchend",
      h = "touchmove",
      d = "touchcancel",
      u = "resize",
      p = "visibilitychange",
      f = "tsParticles - Error",
      m = 100,
      v = 0.5,
      y = 1e3,
      g = { x: 0, y: 0, z: 0 },
      w = { a: 1, b: 0, c: 0, d: 1 },
      _ = "random",
      b = "mid",
      x = 2,
      z = Math.PI * x,
      M = 60,
      P = 1,
      C = "true",
      O = "false",
      k = "canvas",
      S = 0,
      D = 2,
      R = 4,
      E = 1,
      T = 1,
      I = 1,
      L = 4,
      F = 1,
      A = 255,
      V = 360,
      B = 100,
      U = 100,
      W = 0,
      H = 0,
      q = 60,
      G = 0,
      N = 0.25,
      $ = v + N,
      j = 0,
      Q = 1,
      X = 0,
      Y = 0,
      Z = 1,
      J = 1,
      K = 1,
      tt = 1,
      et = 0,
      it = 1,
      st = 0,
      ot = 120,
      nt = 0,
      at = 0,
      rt = 1e4,
      ct = 0,
      lt = 1,
      ht = 0,
      dt = 1,
      ut = 1,
      pt = 0,
      ft = 1,
      mt = 0,
      vt = 0,
      yt = -N,
      gt = 1.5,
      wt = 0,
      _t = 1,
      bt = 0,
      xt = 0,
      zt = 0,
      Mt = 1,
      Pt = 1,
      Ct = 1,
      Ot = 500,
      kt = 50,
      St = 0,
      Dt = 1,
      Rt = 0,
      Et = 1,
      Tt = 0,
      It = 255,
      Lt = 3,
      Ft = 6,
      At = 1,
      Vt = 1,
      Bt = 0,
      Ut = 0,
      Wt = 0,
      Ht = 0;
    var qt;
    function Gt(t) {
      return "boolean" == typeof t;
    }
    function Nt(t) {
      return "string" == typeof t;
    }
    function $t(t) {
      return "number" == typeof t;
    }
    function jt(t) {
      return "function" == typeof t;
    }
    function Qt(t) {
      return "object" == typeof t && null !== t;
    }
    function Xt(t) {
      return Array.isArray(t);
    }
    function Yt(t) {
      return null == t;
    }
    !(function (t) {
      (t.bottom = "bottom"),
        (t.bottomLeft = "bottom-left"),
        (t.bottomRight = "bottom-right"),
        (t.left = "left"),
        (t.none = "none"),
        (t.right = "right"),
        (t.top = "top"),
        (t.topLeft = "top-left"),
        (t.topRight = "top-right"),
        (t.outside = "outside"),
        (t.inside = "inside");
    })(qt || (qt = {}));
    class Zt {
      constructor(t, e, i) {
        if (
          ((this._updateFromAngle = (t, e) => {
            (this.x = Math.cos(t) * e), (this.y = Math.sin(t) * e);
          }),
          !$t(t) && t)
        ) {
          (this.x = t.x), (this.y = t.y);
          const e = t;
          this.z = e.z ? e.z : g.z;
        } else {
          if (void 0 === t || void 0 === e)
            throw new Error(`${f} Vector3d not initialized correctly`);
          (this.x = t), (this.y = e), (this.z = i ?? g.z);
        }
      }
      static get origin() {
        return Zt.create(g.x, g.y, g.z);
      }
      get angle() {
        return Math.atan2(this.y, this.x);
      }
      set angle(t) {
        this._updateFromAngle(t, this.length);
      }
      get length() {
        return Math.sqrt(this.getLengthSq());
      }
      set length(t) {
        this._updateFromAngle(this.angle, t);
      }
      static clone(t) {
        return Zt.create(t.x, t.y, t.z);
      }
      static create(t, e, i) {
        return new Zt(t, e, i);
      }
      add(t) {
        return Zt.create(this.x + t.x, this.y + t.y, this.z + t.z);
      }
      addTo(t) {
        (this.x += t.x), (this.y += t.y), (this.z += t.z);
      }
      copy() {
        return Zt.clone(this);
      }
      distanceTo(t) {
        return this.sub(t).length;
      }
      distanceToSq(t) {
        return this.sub(t).getLengthSq();
      }
      div(t) {
        return Zt.create(this.x / t, this.y / t, this.z / t);
      }
      divTo(t) {
        (this.x /= t), (this.y /= t), (this.z /= t);
      }
      getLengthSq() {
        return this.x ** D + this.y ** D;
      }
      mult(t) {
        return Zt.create(this.x * t, this.y * t, this.z * t);
      }
      multTo(t) {
        (this.x *= t), (this.y *= t), (this.z *= t);
      }
      normalize() {
        const t = this.length;
        t != ht && this.multTo(F / t);
      }
      rotate(t) {
        return Zt.create(
          this.x * Math.cos(t) - this.y * Math.sin(t),
          this.x * Math.sin(t) + this.y * Math.cos(t),
          g.z
        );
      }
      setTo(t) {
        (this.x = t.x), (this.y = t.y);
        const e = t;
        this.z = e.z ? e.z : g.z;
      }
      sub(t) {
        return Zt.create(this.x - t.x, this.y - t.y, this.z - t.z);
      }
      subFrom(t) {
        (this.x -= t.x), (this.y -= t.y), (this.z -= t.z);
      }
    }
    class Jt extends Zt {
      constructor(t, e) {
        super(t, e, g.z);
      }
      static get origin() {
        return Jt.create(g.x, g.y);
      }
      static clone(t) {
        return Jt.create(t.x, t.y);
      }
      static create(t, e) {
        return new Jt(t, e);
      }
    }
    let Kt = Math.random;
    const te = {
      nextFrame: (t) => requestAnimationFrame(t),
      cancel: (t) => cancelAnimationFrame(t),
    };
    function ee(t = Math.random) {
      Kt = t;
    }
    function ie() {
      return ae(Kt(), 0, 1 - Number.EPSILON);
    }
    function se(t, e) {
      (te.nextFrame = (e) => t(e)), (te.cancel = (t) => e(t));
    }
    function oe(t) {
      return te.nextFrame(t);
    }
    function ne(t) {
      te.cancel(t);
    }
    function ae(t, e, i) {
      return Math.min(Math.max(t, e), i);
    }
    function re(t, e, i, s) {
      return Math.floor((t * i + e * s) / (i + s));
    }
    function ce(t) {
      const e = de(t);
      let i = he(t);
      return e === i && (i = 0), ie() * (e - i) + i;
    }
    function le(t) {
      return $t(t) ? t : ce(t);
    }
    function he(t) {
      return $t(t) ? t : t.min;
    }
    function de(t) {
      return $t(t) ? t : t.max;
    }
    function ue(t, e) {
      if (t === e || (void 0 === e && $t(t))) return t;
      const i = he(t),
        s = de(t);
      return void 0 !== e
        ? { min: Math.min(i, e), max: Math.max(s, e) }
        : ue(i, s);
    }
    function pe(t, e) {
      const i = t.x - e.x,
        s = t.y - e.y;
      return { dx: i, dy: s, distance: Math.sqrt(i ** 2 + s ** 2) };
    }
    function fe(t, e) {
      return pe(t, e).distance;
    }
    function me(t) {
      return (t * Math.PI) / 180;
    }
    function ve(t, e, i) {
      if ($t(t)) return me(t);
      switch (t) {
        case qt.top:
          return -Math.PI * v;
        case qt.topRight:
          return -Math.PI * N;
        case qt.right:
          return G;
        case qt.bottomRight:
          return Math.PI * N;
        case qt.bottom:
          return Math.PI * v;
        case qt.bottomLeft:
          return Math.PI * $;
        case qt.left:
          return Math.PI;
        case qt.topLeft:
          return -Math.PI * $;
        case qt.inside:
          return Math.atan2(i.y - e.y, i.x - e.x);
        case qt.outside:
          return Math.atan2(e.y - i.y, e.x - i.x);
        default:
          return ie() * z;
      }
    }
    function ye(t) {
      const e = Jt.origin;
      return (e.length = 1), (e.angle = t), e;
    }
    function ge(t, e, i, s) {
      return Jt.create(
        (t.x * (i - s)) / (i + s) + (e.x * x * s) / (i + s),
        t.y
      );
    }
    function we(t) {
      return void 0 !== t.position?.x && void 0 !== t.position.y
        ? {
            x: (t.position.x * t.size.width) / m,
            y: (t.position.y * t.size.height) / m,
          }
        : void 0;
    }
    function _e(t) {
      return {
        x: ((t.position?.x ?? ie() * m) * t.size.width) / m,
        y: ((t.position?.y ?? ie() * m) * t.size.height) / m,
      };
    }
    function be(t) {
      const e = {
        x: void 0 !== t.position?.x ? le(t.position.x) : void 0,
        y: void 0 !== t.position?.y ? le(t.position.y) : void 0,
      };
      return _e({ size: t.size, position: e });
    }
    function xe(t) {
      return {
        x: t.position?.x ?? ie() * t.size.width,
        y: t.position?.y ?? ie() * t.size.height,
      };
    }
    function ze(t) {
      const e = {
        x: void 0 !== t.position?.x ? le(t.position.x) : void 0,
        y: void 0 !== t.position?.y ? le(t.position.y) : void 0,
      };
      return xe({ size: t.size, position: e });
    }
    function Me(t) {
      return t ? (t.endsWith("%") ? parseFloat(t) / m : parseFloat(t)) : 1;
    }
    var Pe, Ce, Oe, ke, Se, De;
    !(function (t) {
      (t.auto = "auto"),
        (t.increase = "increase"),
        (t.decrease = "decrease"),
        (t.random = "random");
    })(Pe || (Pe = {})),
      (function (t) {
        (t.increasing = "increasing"), (t.decreasing = "decreasing");
      })(Ce || (Ce = {})),
      (function (t) {
        (t.none = "none"), (t.max = "max"), (t.min = "min");
      })(Oe || (Oe = {})),
      (function (t) {
        (t.bottom = "bottom"),
          (t.left = "left"),
          (t.right = "right"),
          (t.top = "top");
      })(ke || (ke = {})),
      (function (t) {
        (t.precise = "precise"), (t.percent = "percent");
      })(Se || (Se = {})),
      (function (t) {
        (t.max = "max"), (t.min = "min"), (t.random = "random");
      })(De || (De = {}));
    const Re = {
      debug: console.debug,
      error: console.error,
      info: console.info,
      log: console.log,
      verbose: console.log,
      warning: console.warn,
    };
    function Ee(t) {
      (Re.debug = t.debug || Re.debug),
        (Re.error = t.error || Re.error),
        (Re.info = t.info || Re.info),
        (Re.log = t.log || Re.log),
        (Re.verbose = t.verbose || Re.verbose),
        (Re.warning = t.warning || Re.warning);
    }
    function Te() {
      return Re;
    }
    function Ie(t) {
      const e = { bounced: !1 },
        {
          pSide: i,
          pOtherSide: s,
          rectSide: o,
          rectOtherSide: n,
          velocity: a,
          factor: r,
        } = t;
      return (
        s.min < n.min ||
          s.min > n.max ||
          s.max < n.min ||
          s.max > n.max ||
          (((i.max >= o.min && i.max <= (o.max + o.min) * v && a > j) ||
            (i.min <= o.max && i.min > (o.max + o.min) * v && a < j)) &&
            ((e.velocity = a * -r), (e.bounced = !0))),
        e
      );
    }
    function Le() {
      return (
        "undefined" == typeof window ||
        !window ||
        void 0 === window.document ||
        !window.document
      );
    }
    function Fe() {
      return !Le() && "undefined" != typeof matchMedia;
    }
    function Ae(t) {
      if (Fe()) return matchMedia(t);
    }
    function Ve(t) {
      if (!Le() && "undefined" != typeof IntersectionObserver)
        return new IntersectionObserver(t);
    }
    function Be(t) {
      if (!Le() && "undefined" != typeof MutationObserver)
        return new MutationObserver(t);
    }
    function Ue(t, e) {
      return t === e || (Xt(e) && e.indexOf(t) > -1);
    }
    async function We(t, e) {
      try {
        await document.fonts.load(`${e ?? "400"} 36px '${t ?? "Verdana"}'`);
      } catch {}
    }
    function He(t) {
      return Math.floor(ie() * t.length);
    }
    function qe(t, e, i = !0) {
      return t[void 0 !== e && i ? e % t.length : He(t)];
    }
    function Ge(t, e, i, s, o) {
      return Ne($e(t, s ?? 0), e, i, o);
    }
    function Ne(t, e, i, s) {
      let o = !0;
      return (
        (s && s !== ke.bottom) || (o = t.top < e.height + i.x),
        !o || (s && s !== ke.left) || (o = t.right > i.x),
        !o || (s && s !== ke.right) || (o = t.left < e.width + i.y),
        !o || (s && s !== ke.top) || (o = t.bottom > i.y),
        o
      );
    }
    function $e(t, e) {
      return { bottom: t.y + e, left: t.x - e, right: t.x + e, top: t.y - e };
    }
    function je(t, ...e) {
      for (const i of e) {
        if (null == i) continue;
        if (!Qt(i)) {
          t = i;
          continue;
        }
        const e = Array.isArray(i);
        !e || (!Qt(t) && t && Array.isArray(t))
          ? e || (!Qt(t) && t && !Array.isArray(t)) || (t = {})
          : (t = []);
        for (const e in i) {
          if ("__proto__" === e) continue;
          const s = i[e],
            o = t;
          o[e] =
            Qt(s) && Array.isArray(s) ? s.map((t) => je(o[e], t)) : je(o[e], s);
        }
      }
      return t;
    }
    function Qe(t, e) {
      return !!si(e, (e) => e.enable && Ue(t, e.mode));
    }
    function Xe(t, e, i) {
      ei(e, (e) => {
        const s = e.mode;
        e.enable && Ue(t, s) && Ye(e, i);
      });
    }
    function Ye(t, e) {
      ei(t.selectors, (i) => {
        e(i, t);
      });
    }
    function Ze(t, e) {
      if (e && t)
        return si(t, (t) =>
          (function (t, e) {
            const i = ei(e, (e) => t.matches(e));
            return Xt(i) ? i.some((t) => t) : i;
          })(e, t.selectors)
        );
    }
    function Je(t) {
      return {
        position: t.getPosition(),
        radius: t.getRadius(),
        mass: t.getMass(),
        velocity: t.velocity,
        factor: Jt.create(
          le(t.options.bounce.horizontal.value),
          le(t.options.bounce.vertical.value)
        ),
      };
    }
    function Ke(t, e) {
      const { x: i, y: s } = t.velocity.sub(e.velocity),
        [o, n] = [t.position, e.position],
        { dx: a, dy: r } = pe(n, o);
      if (i * a + s * r < 0) return;
      const c = -Math.atan2(r, a),
        l = t.mass,
        h = e.mass,
        d = t.velocity.rotate(c),
        u = e.velocity.rotate(c),
        p = ge(d, u, l, h),
        f = ge(u, d, l, h),
        m = p.rotate(-c),
        v = f.rotate(-c);
      (t.velocity.x = m.x * t.factor.x),
        (t.velocity.y = m.y * t.factor.y),
        (e.velocity.x = v.x * e.factor.x),
        (e.velocity.y = v.y * e.factor.y);
    }
    function ti(t, e) {
      const i = $e(t.getPosition(), t.getRadius()),
        s = t.options.bounce,
        o = Ie({
          pSide: { min: i.left, max: i.right },
          pOtherSide: { min: i.top, max: i.bottom },
          rectSide: { min: e.left, max: e.right },
          rectOtherSide: { min: e.top, max: e.bottom },
          velocity: t.velocity.x,
          factor: le(s.horizontal.value),
        });
      o.bounced &&
        (void 0 !== o.velocity && (t.velocity.x = o.velocity),
        void 0 !== o.position && (t.position.x = o.position));
      const n = Ie({
        pSide: { min: i.top, max: i.bottom },
        pOtherSide: { min: i.left, max: i.right },
        rectSide: { min: e.top, max: e.bottom },
        rectOtherSide: { min: e.left, max: e.right },
        velocity: t.velocity.y,
        factor: le(s.vertical.value),
      });
      n.bounced &&
        (void 0 !== n.velocity && (t.velocity.y = n.velocity),
        void 0 !== n.position && (t.position.y = n.position));
    }
    function ei(t, e) {
      return Xt(t) ? t.map((t, i) => e(t, i)) : e(t, 0);
    }
    function ii(t, e, i) {
      return Xt(t) ? qe(t, e, i) : t;
    }
    function si(t, e) {
      if (Xt(t)) return t.find((t, i) => e(t, i));
      return e(t, 0) ? t : void 0;
    }
    function oi(t, e) {
      const i = t.value,
        s = t.animation,
        o = {
          delayTime: le(s.delay) * y,
          enable: s.enable,
          value: le(t.value) * e,
          max: de(i) * e,
          min: he(i) * e,
          loops: 0,
          maxLoops: le(s.count),
          time: 0,
        };
      if (s.enable) {
        switch (((o.decay = 1 - le(s.decay)), s.mode)) {
          case Pe.increase:
            o.status = Ce.increasing;
            break;
          case Pe.decrease:
            o.status = Ce.decreasing;
            break;
          case Pe.random:
            o.status = ie() >= v ? Ce.increasing : Ce.decreasing;
        }
        const t = s.mode === Pe.auto;
        switch (s.startValue) {
          case De.min:
            (o.value = o.min), t && (o.status = Ce.increasing);
            break;
          case De.max:
            (o.value = o.max), t && (o.status = Ce.decreasing);
            break;
          case De.random:
          default:
            (o.value = ce(o)),
              t && (o.status = ie() >= v ? Ce.increasing : Ce.decreasing);
        }
      }
      return (o.initialValue = o.value), o;
    }
    function ni(t, e) {
      if (!(t.mode === Se.percent)) {
        const { mode: e, ...i } = t;
        return i;
      }
      return "x" in t
        ? { x: (t.x / m) * e.width, y: (t.y / m) * e.height }
        : { width: (t.width / m) * e.width, height: (t.height / m) * e.height };
    }
    function ai(t, e) {
      return ni(t, e);
    }
    function ri(t, e) {
      return ni(t, e);
    }
    function ci(t, e, i, s, o) {
      if (
        t.destroyed ||
        !e ||
        !e.enable ||
        ((e.maxLoops ?? 0) > 0 && (e.loops ?? 0) > (e.maxLoops ?? 0))
      )
        return;
      const n = (e.velocity ?? 0) * o.factor,
        a = e.min,
        r = e.max,
        c = e.decay ?? 1;
      if (
        (e.time || (e.time = 0),
        (e.delayTime ?? 0) > 0 &&
          e.time < (e.delayTime ?? 0) &&
          (e.time += o.value),
        !((e.delayTime ?? 0) > 0 && e.time < (e.delayTime ?? 0)))
      ) {
        switch (e.status) {
          case Ce.increasing:
            e.value >= r
              ? (i ? (e.status = Ce.decreasing) : (e.value -= r),
                e.loops || (e.loops = 0),
                e.loops++)
              : (e.value += n);
            break;
          case Ce.decreasing:
            e.value <= a
              ? (i ? (e.status = Ce.increasing) : (e.value += r),
                e.loops || (e.loops = 0),
                e.loops++)
              : (e.value -= n);
        }
        e.velocity && 1 !== c && (e.velocity *= c),
          (function (t, e, i, s, o) {
            switch (e) {
              case Oe.max:
                i >= o && t.destroy();
                break;
              case Oe.min:
                i <= s && t.destroy();
            }
          })(t, s, e.value, a, r),
          t.destroyed || (e.value = ae(e.value, a, r));
      }
    }
    function li(t) {
      const e = document.createElement("div").style;
      if (!t) return e;
      for (const i in t) {
        const s = t[i];
        if (!Object.prototype.hasOwnProperty.call(t, i) || Yt(s)) continue;
        const o = t.getPropertyValue?.(s);
        if (!o) continue;
        const n = t.getPropertyPriority?.(s);
        n ? e.setProperty?.(s, o, n) : e.setProperty?.(s, o);
      }
      return e;
    }
    const hi = (function (t) {
      const e = new Map();
      return (...i) => {
        const s = JSON.stringify(i);
        if (e.has(s)) return e.get(s);
        const o = t(...i);
        return e.set(s, o), o;
      };
    })(function (t) {
      const e = document.createElement("div").style,
        i = {
          width: "100%",
          height: "100%",
          margin: "0",
          padding: "0",
          borderWidth: "0",
          position: "fixed",
          zIndex: t.toString(10),
          "z-index": t.toString(10),
          top: "0",
          left: "0",
        };
      for (const t in i) {
        const s = i[t];
        e.setProperty(t, s);
      }
      return e;
    });
    var di, ui, pi, fi, mi, vi, yi, gi, wi, _i, bi, xi;
    function zi(t, e) {
      if (e)
        for (const i of t.colorManagers.values())
          if (e.startsWith(i.stringPrefix)) return i.parseString(e);
    }
    function Mi(t, e, i, s = !0) {
      if (!e) return;
      const o = Nt(e) ? { value: e } : e;
      if (Nt(o.value)) return Pi(t, o.value, i, s);
      if (Xt(o.value)) return Mi(t, { value: qe(o.value, i, s) });
      for (const e of t.colorManagers.values()) {
        const t = e.handleRangeColor(o);
        if (t) return t;
      }
    }
    function Pi(t, e, i, s = !0) {
      if (!e) return;
      const o = Nt(e) ? { value: e } : e;
      if (Nt(o.value)) return o.value === _ ? Ti() : Di(t, o.value);
      if (Xt(o.value)) return Pi(t, { value: qe(o.value, i, s) });
      for (const e of t.colorManagers.values()) {
        const t = e.handleColor(o);
        if (t) return t;
      }
    }
    function Ci(t, e, i, s = !0) {
      const o = Pi(t, e, i, s);
      return o ? ki(o) : void 0;
    }
    function Oi(t, e, i, s = !0) {
      const o = Mi(t, e, i, s);
      return o ? ki(o) : void 0;
    }
    function ki(t) {
      const e = t.r / A,
        i = t.g / A,
        s = t.b / A,
        o = Math.max(e, i, s),
        n = Math.min(e, i, s),
        a = { h: W, l: (o + n) * v, s: H };
      return (
        o !== n &&
          ((a.s = a.l < v ? (o - n) / (o + n) : (o - n) / (x - o - n)),
          (a.h =
            e === o
              ? (i - s) / (o - n)
              : (a.h =
                  i === o
                    ? x + (s - e) / (o - n)
                    : x * x + (e - i) / (o - n)))),
        (a.l *= U),
        (a.s *= B),
        (a.h *= q),
        a.h < W && (a.h += V),
        a.h >= V && (a.h -= V),
        a
      );
    }
    function Si(t, e) {
      return zi(t, e)?.a;
    }
    function Di(t, e) {
      return zi(t, e);
    }
    function Ri(t) {
      const e = ((t.h % V) + V) % V,
        i = Math.max(H, Math.min(B, t.s)),
        s = Math.max(Tt, Math.min(U, t.l)),
        o = e / V,
        n = i / B,
        a = s / U;
      if (i === H) {
        const t = Math.round(a * It);
        return { r: t, g: t, b: t };
      }
      const r = (t, e, i) => {
          if ((i < 0 && i++, i > 1 && i--, i * Ft < 1))
            return t + (e - t) * Ft * i;
          if (i * x < 1) return e;
          if (i * Lt < 1 * x) {
            return t + (e - t) * (x / Lt - i) * Ft;
          }
          return t;
        },
        c = a < v ? a * (At + n) : a + n - a * n,
        l = x * a - c,
        h = Vt / Lt,
        d = Math.min(It, It * r(l, c, o + h)),
        u = Math.min(It, It * r(l, c, o)),
        p = Math.min(It, It * r(l, c, o - h));
      return { r: Math.round(d), g: Math.round(u), b: Math.round(p) };
    }
    function Ei(t) {
      const e = Ri(t);
      return { a: t.a, b: e.b, g: e.g, r: e.r };
    }
    function Ti(t) {
      const e = t ?? Bt,
        i = A + Dt;
      return {
        b: Math.floor(ce(ue(e, i))),
        g: Math.floor(ce(ue(e, i))),
        r: Math.floor(ce(ue(e, i))),
      };
    }
    function Ii(t, e) {
      return `rgba(${t.r}, ${t.g}, ${t.b}, ${e ?? J})`;
    }
    function Li(t, e) {
      return `hsla(${t.h}, ${t.s}%, ${t.l}%, ${e ?? J})`;
    }
    function Fi(t, e, i, s) {
      let o = t,
        n = e;
      return (
        void 0 === o.r && (o = Ri(t)),
        void 0 === n.r && (n = Ri(e)),
        { b: re(o.b, n.b, i, s), g: re(o.g, n.g, i, s), r: re(o.r, n.r, i, s) }
      );
    }
    function Ai(t, e, i) {
      if (i === _) return Ti();
      if (i !== b) return i;
      {
        const i = t.getFillColor() ?? t.getStrokeColor(),
          s = e?.getFillColor() ?? e?.getStrokeColor();
        if (i && s && e) return Fi(i, s, t.getRadius(), e.getRadius());
        {
          const t = i ?? s;
          if (t) return Ri(t);
        }
      }
    }
    function Vi(t, e, i, s) {
      const o = Nt(e) ? e : e.value;
      return o === _
        ? s
          ? Mi(t, { value: o })
          : i
          ? _
          : b
        : o === b
        ? b
        : Mi(t, { value: o });
    }
    function Bi(t) {
      return void 0 !== t
        ? { h: t.h.value, s: t.s.value, l: t.l.value }
        : void 0;
    }
    function Ui(t, e, i) {
      const s = {
        h: { enable: !1, value: t.h },
        s: { enable: !1, value: t.s },
        l: { enable: !1, value: t.l },
      };
      return e && (Wi(s.h, e.h, i), Wi(s.s, e.s, i), Wi(s.l, e.l, i)), s;
    }
    function Wi(t, e, i) {
      (t.enable = e.enable),
        t.enable
          ? ((t.velocity = (le(e.speed) / m) * i),
            (t.decay = dt - le(e.decay)),
            (t.status = Ce.increasing),
            (t.loops = Wt),
            (t.maxLoops = le(e.count)),
            (t.time = Ht),
            (t.delayTime = le(e.delay) * y),
            e.sync || ((t.velocity *= ie()), (t.value *= ie())),
            (t.initialValue = t.value),
            (t.offset = ue(e.offset)))
          : (t.velocity = Ut);
    }
    function Hi(t, e, i, s) {
      if (
        !t ||
        !t.enable ||
        ((t.maxLoops ?? 0) > 0 && (t.loops ?? 0) > (t.maxLoops ?? 0))
      )
        return;
      if (
        (t.time || (t.time = 0),
        (t.delayTime ?? 0) > 0 &&
          t.time < (t.delayTime ?? 0) &&
          (t.time += s.value),
        (t.delayTime ?? 0) > 0 && t.time < (t.delayTime ?? 0))
      )
        return;
      const o = t.offset ? ce(t.offset) : 0,
        n = (t.velocity ?? 0) * s.factor + 3.6 * o,
        a = t.decay ?? 1,
        r = de(e),
        c = he(e);
      if (i && t.status !== Ce.increasing) {
        t.value -= n;
        const e = 0;
        t.value < e &&
          (t.loops || (t.loops = 0), t.loops++, (t.status = Ce.increasing));
      } else
        (t.value += n),
          t.value > r &&
            (t.loops || (t.loops = 0),
            t.loops++,
            i ? (t.status = Ce.decreasing) : (t.value -= r));
      t.velocity && 1 !== a && (t.velocity *= a), (t.value = ae(t.value, c, r));
    }
    function qi(t, e) {
      if (!t) return;
      const { h: i, s, l: o } = t,
        n = { min: 0, max: 100 },
        a = { min: 0, max: 100 };
      i && Hi(i, { min: 0, max: 360 }, !1, e),
        s && Hi(s, n, !0, e),
        o && Hi(o, a, !0, e);
    }
    function Gi(t, e, i) {
      t.beginPath(), t.moveTo(e.x, e.y), t.lineTo(i.x, i.y), t.closePath();
    }
    function Ni(t, e, i) {
      (t.fillStyle = i ?? "rgba(0,0,0,0)"),
        t.fillRect(g.x, g.y, e.width, e.height);
    }
    function $i(t, e, i, s) {
      i &&
        ((t.globalAlpha = s),
        t.drawImage(i, g.x, g.y, e.width, e.height),
        (t.globalAlpha = 1));
    }
    function ji(t, e) {
      t.clearRect(g.x, g.y, e.width, e.height);
    }
    function Qi(t) {
      const {
          container: e,
          context: i,
          particle: s,
          delta: o,
          colorStyles: n,
          backgroundMask: a,
          composite: r,
          radius: c,
          opacity: l,
          shadow: h,
          transform: d,
        } = t,
        u = s.getPosition(),
        p = s.rotation + (s.pathRotation ? s.velocity.angle : St),
        f = Math.sin(p),
        m = Math.cos(p),
        v = !!p,
        y = {
          a: m * (d.a ?? w.a),
          b: v ? f * (d.b ?? Dt) : d.b ?? w.b,
          c: v ? -f * (d.c ?? Dt) : d.c ?? w.c,
          d: m * (d.d ?? w.d),
        };
      i.setTransform(y.a, y.b, y.c, y.d, u.x, u.y),
        a && (i.globalCompositeOperation = r);
      const g = s.shadowColor;
      h.enable &&
        g &&
        ((i.shadowBlur = h.blur),
        (i.shadowColor = Ii(g)),
        (i.shadowOffsetX = h.offset.x),
        (i.shadowOffsetY = h.offset.y)),
        n.fill && (i.fillStyle = n.fill);
      const _ = s.strokeWidth ?? Rt;
      (i.lineWidth = _), n.stroke && (i.strokeStyle = n.stroke);
      const b = {
        container: e,
        context: i,
        particle: s,
        radius: c,
        opacity: l,
        delta: o,
        transformData: y,
        strokeWidth: _,
      };
      Yi(b),
        Zi(b),
        Xi(b),
        (i.globalCompositeOperation = "source-over"),
        i.resetTransform();
    }
    function Xi(t) {
      const {
        container: e,
        context: i,
        particle: s,
        radius: o,
        opacity: n,
        delta: a,
        transformData: r,
      } = t;
      if (!s.effect) return;
      const c = e.effectDrawers.get(s.effect);
      c &&
        c.draw({
          context: i,
          particle: s,
          radius: o,
          opacity: n,
          delta: a,
          pixelRatio: e.retina.pixelRatio,
          transformData: { ...r },
        });
    }
    function Yi(t) {
      const {
        container: e,
        context: i,
        particle: s,
        radius: o,
        opacity: n,
        delta: a,
        strokeWidth: r,
        transformData: c,
      } = t;
      if (!s.shape) return;
      const l = e.shapeDrawers.get(s.shape);
      l &&
        (i.beginPath(),
        l.draw({
          context: i,
          particle: s,
          radius: o,
          opacity: n,
          delta: a,
          pixelRatio: e.retina.pixelRatio,
          transformData: { ...c },
        }),
        s.shapeClose && i.closePath(),
        r > Rt && i.stroke(),
        s.shapeFill && i.fill());
    }
    function Zi(t) {
      const {
        container: e,
        context: i,
        particle: s,
        radius: o,
        opacity: n,
        delta: a,
        transformData: r,
      } = t;
      if (!s.shape) return;
      const c = e.shapeDrawers.get(s.shape);
      c?.afterDraw &&
        c.afterDraw({
          context: i,
          particle: s,
          radius: o,
          opacity: n,
          delta: a,
          pixelRatio: e.retina.pixelRatio,
          transformData: { ...r },
        });
    }
    function Ji(t, e, i) {
      e.draw && e.draw(t, i);
    }
    function Ki(t, e, i, s) {
      e.drawParticle && e.drawParticle(t, i, s);
    }
    function ts(t, e, i) {
      return { h: t.h, s: t.s, l: t.l + (e === di.darken ? -Et : Et) * i };
    }
    function es(t, e, i) {
      const s = e[i];
      void 0 !== s && (t[i] = (t[i] ?? Q) * s);
    }
    function is(t, e, i = !1) {
      if (!e) return;
      if (!t) return;
      const s = t.style;
      if (!s) return;
      const o = new Set();
      for (const t in s)
        Object.prototype.hasOwnProperty.call(s, t) && o.add(s[t]);
      for (const t in e)
        Object.prototype.hasOwnProperty.call(e, t) && o.add(e[t]);
      for (const t of o) {
        const o = e.getPropertyValue(t);
        o ? s.setProperty(t, o, i ? "important" : "") : s.removeProperty(t);
      }
    }
    !(function (t) {
      (t.darken = "darken"), (t.enlighten = "enlighten");
    })(di || (di = {}));
    class ss {
      constructor(t, e) {
        (this.container = t),
          (this._applyPostDrawUpdaters = (t) => {
            for (const e of this._postDrawUpdaters) e.afterDraw?.(t);
          }),
          (this._applyPreDrawUpdaters = (t, e, i, s, o, n) => {
            for (const a of this._preDrawUpdaters) {
              if (a.getColorStyles) {
                const { fill: n, stroke: r } = a.getColorStyles(e, t, i, s);
                n && (o.fill = n), r && (o.stroke = r);
              }
              if (a.getTransformValues) {
                const t = a.getTransformValues(e);
                for (const e in t) es(n, t, e);
              }
              a.beforeDraw?.(e);
            }
          }),
          (this._applyResizePlugins = () => {
            for (const t of this._resizePlugins) t.resize?.();
          }),
          (this._getPluginParticleColors = (t) => {
            let e, i;
            for (const s of this._colorPlugins)
              if (
                (!e &&
                  s.particleFillColor &&
                  (e = Oi(this._engine, s.particleFillColor(t))),
                !i &&
                  s.particleStrokeColor &&
                  (i = Oi(this._engine, s.particleStrokeColor(t))),
                e && i)
              )
                break;
            return [e, i];
          }),
          (this._initCover = async () => {
            const t = this.container.actualOptions.backgroundMask.cover,
              e = t.color;
            if (e) {
              const i = Mi(this._engine, e);
              if (i) {
                const e = { ...i, a: t.opacity };
                this._coverColorStyle = Ii(e, e.a);
              }
            } else
              await new Promise((e, i) => {
                if (!t.image) return;
                const s = document.createElement("img");
                s.addEventListener("load", () => {
                  (this._coverImage = { image: s, opacity: t.opacity }), e();
                }),
                  s.addEventListener("error", (t) => {
                    i(t.error);
                  }),
                  (s.src = t.image);
              });
          }),
          (this._initStyle = () => {
            const t = this.element,
              e = this.container.actualOptions;
            if (t) {
              this._fullScreen
                ? this._setFullScreenStyle()
                : this._resetOriginalStyle();
              for (const i in e.style) {
                if (
                  !i ||
                  !e.style ||
                  !Object.prototype.hasOwnProperty.call(e.style, i)
                )
                  continue;
                const s = e.style[i];
                s && t.style.setProperty(i, s, "important");
              }
            }
          }),
          (this._initTrail = async () => {
            const t = this.container.actualOptions.particles.move.trail,
              e = t.fill;
            if (!t.enable) return;
            const i = F / t.length;
            if (e.color) {
              const t = Mi(this._engine, e.color);
              if (!t) return;
              this._trailFill = { color: { ...t }, opacity: i };
            } else
              await new Promise((t, s) => {
                if (!e.image) return;
                const o = document.createElement("img");
                o.addEventListener("load", () => {
                  (this._trailFill = { image: o, opacity: i }), t();
                }),
                  o.addEventListener("error", (t) => {
                    s(t.error);
                  }),
                  (o.src = e.image);
              });
          }),
          (this._paintBase = (t) => {
            this.draw((e) => Ni(e, this.size, t));
          }),
          (this._paintImage = (t, e) => {
            this.draw((i) => $i(i, this.size, t, e));
          }),
          (this._repairStyle = () => {
            const t = this.element;
            t &&
              (this._safeMutationObserver((t) => t.disconnect()),
              this._initStyle(),
              this.initBackground(),
              this._safeMutationObserver((e) => {
                t && t instanceof Node && e.observe(t, { attributes: !0 });
              }));
          }),
          (this._resetOriginalStyle = () => {
            const t = this.element,
              e = this._originalStyle;
            t && e && is(t, e, !0);
          }),
          (this._safeMutationObserver = (t) => {
            this._mutationObserver && t(this._mutationObserver);
          }),
          (this._setFullScreenStyle = () => {
            const t = this.element;
            t && is(t, hi(this.container.actualOptions.fullScreen.zIndex), !0);
          }),
          (this._engine = e),
          (this._standardSize = { height: 0, width: 0 });
        const i = t.retina.pixelRatio,
          s = this._standardSize;
        (this.size = { height: s.height * i, width: s.width * i }),
          (this._context = null),
          (this._generated = !1),
          (this._preDrawUpdaters = []),
          (this._postDrawUpdaters = []),
          (this._resizePlugins = []),
          (this._colorPlugins = []);
      }
      get _fullScreen() {
        return this.container.actualOptions.fullScreen.enable;
      }
      clear() {
        const t = this.container.actualOptions,
          e = t.particles.move.trail,
          i = this._trailFill;
        t.backgroundMask.enable
          ? this.paint()
          : e.enable && e.length > Y && i
          ? i.color
            ? this._paintBase(Ii(i.color, i.opacity))
            : i.image && this._paintImage(i.image, i.opacity)
          : t.clear &&
            this.draw((t) => {
              ji(t, this.size);
            });
      }
      destroy() {
        if ((this.stop(), this._generated)) {
          const t = this.element;
          t?.remove(), (this.element = void 0);
        } else this._resetOriginalStyle();
        (this._preDrawUpdaters = []),
          (this._postDrawUpdaters = []),
          (this._resizePlugins = []),
          (this._colorPlugins = []);
      }
      draw(t) {
        const e = this._context;
        if (e) return t(e);
      }
      drawAsync(t) {
        const e = this._context;
        if (e) return t(e);
      }
      drawParticle(t, e) {
        if (t.spawning || t.destroyed) return;
        const i = t.getRadius();
        if (i <= X) return;
        const s = t.getFillColor(),
          o = t.getStrokeColor() ?? s;
        let [n, a] = this._getPluginParticleColors(t);
        n || (n = s),
          a || (a = o),
          (n || a) &&
            this.draw((s) => {
              const o = this.container,
                r = o.actualOptions,
                c = t.options.zIndex,
                l = Z - t.zIndexFactor,
                h = l ** c.opacityRate,
                d = t.bubble.opacity ?? t.opacity?.value ?? J,
                u = d * h,
                p = (t.strokeOpacity ?? d) * h,
                f = {},
                m = { fill: n ? Li(n, u) : void 0 };
              (m.stroke = a ? Li(a, p) : m.fill),
                this._applyPreDrawUpdaters(s, t, i, u, m, f),
                Qi({
                  container: o,
                  context: s,
                  particle: t,
                  delta: e,
                  colorStyles: m,
                  backgroundMask: r.backgroundMask.enable,
                  composite: r.backgroundMask.composite,
                  radius: i * l ** c.sizeRate,
                  opacity: u,
                  shadow: t.options.shadow,
                  transform: f,
                }),
                this._applyPostDrawUpdaters(t);
            });
      }
      drawParticlePlugin(t, e, i) {
        this.draw((s) => Ki(s, t, e, i));
      }
      drawPlugin(t, e) {
        this.draw((i) => Ji(i, t, e));
      }
      async init() {
        this._safeMutationObserver((t) => t.disconnect()),
          (this._mutationObserver = Be((t) => {
            for (const e of t)
              "attributes" === e.type &&
                "style" === e.attributeName &&
                this._repairStyle();
          })),
          this.resize(),
          this._initStyle(),
          await this._initCover();
        try {
          await this._initTrail();
        } catch (t) {
          Te().error(t);
        }
        this.initBackground(),
          this._safeMutationObserver((t) => {
            this.element &&
              this.element instanceof Node &&
              t.observe(this.element, { attributes: !0 });
          }),
          this.initUpdaters(),
          this.initPlugins(),
          this.paint();
      }
      initBackground() {
        const t = this.container.actualOptions.background,
          e = this.element;
        if (!e) return;
        const i = e.style;
        if (i) {
          if (t.color) {
            const e = Mi(this._engine, t.color);
            i.backgroundColor = e ? Ii(e, t.opacity) : "";
          } else i.backgroundColor = "";
          (i.backgroundImage = t.image || ""),
            (i.backgroundPosition = t.position || ""),
            (i.backgroundRepeat = t.repeat || ""),
            (i.backgroundSize = t.size || "");
        }
      }
      initPlugins() {
        this._resizePlugins = [];
        for (const t of this.container.plugins.values())
          t.resize && this._resizePlugins.push(t),
            (t.particleFillColor ?? t.particleStrokeColor) &&
              this._colorPlugins.push(t);
      }
      initUpdaters() {
        (this._preDrawUpdaters = []), (this._postDrawUpdaters = []);
        for (const t of this.container.particles.updaters)
          t.afterDraw && this._postDrawUpdaters.push(t),
            (t.getColorStyles ?? t.getTransformValues ?? t.beforeDraw) &&
              this._preDrawUpdaters.push(t);
      }
      loadCanvas(t) {
        this._generated && this.element && this.element.remove(),
          (this._generated =
            t.dataset && i in t.dataset
              ? "true" === t.dataset[i]
              : this._generated),
          (this.element = t),
          (this.element.ariaHidden = "true"),
          (this._originalStyle = li(this.element.style));
        const e = this._standardSize;
        (e.height = t.offsetHeight), (e.width = t.offsetWidth);
        const s = this.container.retina.pixelRatio,
          o = this.size;
        (t.height = o.height = e.height * s),
          (t.width = o.width = e.width * s),
          (this._context = this.element.getContext("2d")),
          this._safeMutationObserver((t) => t.disconnect()),
          this.container.retina.init(),
          this.initBackground(),
          this._safeMutationObserver((t) => {
            this.element &&
              this.element instanceof Node &&
              t.observe(this.element, { attributes: !0 });
          });
      }
      paint() {
        const t = this.container.actualOptions;
        this.draw((e) => {
          t.backgroundMask.enable && t.backgroundMask.cover
            ? (ji(e, this.size),
              this._coverImage
                ? this._paintImage(
                    this._coverImage.image,
                    this._coverImage.opacity
                  )
                : this._coverColorStyle
                ? this._paintBase(this._coverColorStyle)
                : this._paintBase())
            : this._paintBase();
        });
      }
      resize() {
        if (!this.element) return !1;
        const t = this.container,
          e = t.canvas._standardSize,
          i = {
            width: this.element.offsetWidth,
            height: this.element.offsetHeight,
          },
          s = t.retina.pixelRatio,
          o = { width: i.width * s, height: i.height * s };
        if (
          i.height === e.height &&
          i.width === e.width &&
          o.height === this.element.height &&
          o.width === this.element.width
        )
          return !1;
        const n = { ...e };
        (e.height = i.height), (e.width = i.width);
        const a = this.size;
        return (
          (this.element.width = a.width = o.width),
          (this.element.height = a.height = o.height),
          this.container.started &&
            t.particles.setResizeFactor({
              width: e.width / n.width,
              height: e.height / n.height,
            }),
          !0
        );
      }
      stop() {
        this._safeMutationObserver((t) => t.disconnect()),
          (this._mutationObserver = void 0),
          this.draw((t) => ji(t, this.size));
      }
      async windowResize() {
        if (!this.element || !this.resize()) return;
        const t = this.container,
          e = t.updateActualOptions();
        t.particles.setDensity(),
          this._applyResizePlugins(),
          e && (await t.refresh());
      }
    }
    function os(t, e, i, s, o) {
      if (s) {
        let s = { passive: !0 };
        Gt(o) ? (s.capture = o) : void 0 !== o && (s = o),
          t.addEventListener(e, i, s);
      } else {
        const s = o;
        t.removeEventListener(e, i, s);
      }
    }
    !(function (t) {
      (t.canvas = "canvas"), (t.parent = "parent"), (t.window = "window");
    })(ui || (ui = {}));
    class ns {
      constructor(t) {
        (this.container = t),
          (this._doMouseTouchClick = (t) => {
            const e = this.container,
              i = e.actualOptions;
            if (this._canPush) {
              const t = e.interactivity.mouse,
                s = t.position;
              if (!s) return;
              (t.clickPosition = { ...s }),
                (t.clickTime = new Date().getTime());
              ei(i.interactivity.events.onClick.mode, (t) =>
                this.container.handleClickMode(t)
              );
            }
            "touchend" === t.type &&
              setTimeout(() => this._mouseTouchFinish(), Ot);
          }),
          (this._handleThemeChange = (t) => {
            const e = t,
              i = this.container,
              s = i.options,
              o = s.defaultThemes,
              n = e.matches ? o.dark : o.light,
              a = s.themes.find((t) => t.name === n);
            a?.default.auto && i.loadTheme(n);
          }),
          (this._handleVisibilityChange = () => {
            const t = this.container,
              e = t.actualOptions;
            this._mouseTouchFinish(),
              e.pauseOnBlur &&
                (document?.hidden
                  ? ((t.pageHidden = !0), t.pause())
                  : ((t.pageHidden = !1),
                    t.animationStatus ? t.play(!0) : t.draw(!0)));
          }),
          (this._handleWindowResize = () => {
            this._resizeTimeout &&
              (clearTimeout(this._resizeTimeout), delete this._resizeTimeout);
            const t = async () => {
              const t = this.container.canvas;
              await t?.windowResize();
            };
            this._resizeTimeout = setTimeout(() => {
              t();
            }, this.container.actualOptions.interactivity.events.resize.delay * y);
          }),
          (this._manageInteractivityListeners = (t, e) => {
            const i = this._handlers,
              n = this.container,
              a = n.actualOptions,
              u = n.interactivity.element;
            if (!u) return;
            const p = u,
              f = n.canvas.element;
            f && (f.style.pointerEvents = p === f ? "initial" : "none"),
              (a.interactivity.events.onHover.enable ||
                a.interactivity.events.onClick.enable) &&
                (os(u, r, i.mouseMove, e),
                os(u, c, i.touchStart, e),
                os(u, h, i.touchMove, e),
                a.interactivity.events.onClick.enable
                  ? (os(u, l, i.touchEndClick, e),
                    os(u, o, i.mouseUp, e),
                    os(u, s, i.mouseDown, e))
                  : os(u, l, i.touchEnd, e),
                os(u, t, i.mouseLeave, e),
                os(u, d, i.touchCancel, e));
          }),
          (this._manageListeners = (t) => {
            const e = this._handlers,
              i = this.container,
              s = i.actualOptions.interactivity.detectsOn,
              o = i.canvas.element;
            let r = n;
            s === ui.window
              ? ((i.interactivity.element = window), (r = a))
              : s === ui.parent && o
              ? (i.interactivity.element = o.parentElement ?? o.parentNode)
              : (i.interactivity.element = o),
              this._manageMediaMatch(t),
              this._manageResize(t),
              this._manageInteractivityListeners(r, t),
              document && os(document, p, e.visibilityChange, t, !1);
          }),
          (this._manageMediaMatch = (t) => {
            const e = this._handlers,
              i = Ae("(prefers-color-scheme: dark)");
            i &&
              (void 0 === i.addEventListener
                ? void 0 !== i.addListener &&
                  (t
                    ? i.addListener(e.oldThemeChange)
                    : i.removeListener(e.oldThemeChange))
                : os(i, "change", e.themeChange, t));
          }),
          (this._manageResize = (t) => {
            const e = this._handlers,
              i = this.container;
            if (!i.actualOptions.interactivity.events.resize) return;
            if ("undefined" == typeof ResizeObserver)
              return void os(window, u, e.resize, t);
            const s = i.canvas.element;
            this._resizeObserver && !t
              ? (s && this._resizeObserver.unobserve(s),
                this._resizeObserver.disconnect(),
                delete this._resizeObserver)
              : !this._resizeObserver &&
                t &&
                s &&
                ((this._resizeObserver = new ResizeObserver((t) => {
                  t.find((t) => t.target === s) && this._handleWindowResize();
                })),
                this._resizeObserver.observe(s));
          }),
          (this._mouseDown = () => {
            const { interactivity: t } = this.container;
            if (!t) return;
            const { mouse: e } = t;
            (e.clicking = !0), (e.downPosition = e.position);
          }),
          (this._mouseTouchClick = (t) => {
            const e = this.container,
              i = e.actualOptions,
              { mouse: s } = e.interactivity;
            s.inside = !0;
            let o = !1;
            const n = s.position;
            if (n && i.interactivity.events.onClick.enable) {
              for (const t of e.plugins.values())
                if (t.clickPositionValid && ((o = t.clickPositionValid(n)), o))
                  break;
              o || this._doMouseTouchClick(t), (s.clicking = !1);
            }
          }),
          (this._mouseTouchFinish = () => {
            const t = this.container.interactivity;
            if (!t) return;
            const e = t.mouse;
            delete e.position,
              delete e.clickPosition,
              delete e.downPosition,
              (t.status = n),
              (e.inside = !1),
              (e.clicking = !1);
          }),
          (this._mouseTouchMove = (t) => {
            const e = this.container,
              i = e.actualOptions,
              s = e.interactivity,
              o = e.canvas.element;
            if (!s?.element) return;
            let n;
            if (((s.mouse.inside = !0), t.type.startsWith("pointer"))) {
              this._canPush = !0;
              const e = t;
              if (s.element === window) {
                if (o) {
                  const t = o.getBoundingClientRect();
                  n = { x: e.clientX - t.left, y: e.clientY - t.top };
                }
              } else if (i.interactivity.detectsOn === ui.parent) {
                const t = e.target,
                  i = e.currentTarget;
                if (t && i && o) {
                  const s = t.getBoundingClientRect(),
                    a = i.getBoundingClientRect(),
                    r = o.getBoundingClientRect();
                  n = {
                    x: e.offsetX + x * s.left - (a.left + r.left),
                    y: e.offsetY + x * s.top - (a.top + r.top),
                  };
                } else
                  n = { x: e.offsetX ?? e.clientX, y: e.offsetY ?? e.clientY };
              } else
                e.target === o &&
                  (n = {
                    x: e.offsetX ?? e.clientX,
                    y: e.offsetY ?? e.clientY,
                  });
            } else if (((this._canPush = "touchmove" !== t.type), o)) {
              const e = t,
                i = e.touches[e.touches.length - Mt],
                s = o.getBoundingClientRect();
              n = {
                x: i.clientX - (s.left ?? et),
                y: i.clientY - (s.top ?? et),
              };
            }
            const a = e.retina.pixelRatio;
            n && ((n.x *= a), (n.y *= a)),
              (s.mouse.position = n),
              (s.status = r);
          }),
          (this._touchEnd = (t) => {
            const e = t,
              i = Array.from(e.changedTouches);
            for (const t of i) this._touches.delete(t.identifier);
            this._mouseTouchFinish();
          }),
          (this._touchEndClick = (t) => {
            const e = t,
              i = Array.from(e.changedTouches);
            for (const t of i) this._touches.delete(t.identifier);
            this._mouseTouchClick(t);
          }),
          (this._touchStart = (t) => {
            const e = t,
              i = Array.from(e.changedTouches);
            for (const t of i)
              this._touches.set(t.identifier, performance.now());
            this._mouseTouchMove(t);
          }),
          (this._canPush = !0),
          (this._touches = new Map()),
          (this._handlers = {
            mouseDown: () => this._mouseDown(),
            mouseLeave: () => this._mouseTouchFinish(),
            mouseMove: (t) => this._mouseTouchMove(t),
            mouseUp: (t) => this._mouseTouchClick(t),
            touchStart: (t) => this._touchStart(t),
            touchMove: (t) => this._mouseTouchMove(t),
            touchEnd: (t) => this._touchEnd(t),
            touchCancel: (t) => this._touchEnd(t),
            touchEndClick: (t) => this._touchEndClick(t),
            visibilityChange: () => this._handleVisibilityChange(),
            themeChange: (t) => this._handleThemeChange(t),
            oldThemeChange: (t) => this._handleThemeChange(t),
            resize: () => {
              this._handleWindowResize();
            },
          });
      }
      addListeners() {
        this._manageListeners(!0);
      }
      removeListeners() {
        this._manageListeners(!1);
      }
    }
    !(function (t) {
      (t.configAdded = "configAdded"),
        (t.containerInit = "containerInit"),
        (t.particlesSetup = "particlesSetup"),
        (t.containerStarted = "containerStarted"),
        (t.containerStopped = "containerStopped"),
        (t.containerDestroyed = "containerDestroyed"),
        (t.containerPaused = "containerPaused"),
        (t.containerPlay = "containerPlay"),
        (t.containerBuilt = "containerBuilt"),
        (t.particleAdded = "particleAdded"),
        (t.particleDestroyed = "particleDestroyed"),
        (t.particleRemoved = "particleRemoved");
    })(pi || (pi = {}));
    class as {
      constructor() {
        this.value = "";
      }
      static create(t, e) {
        const i = new as();
        return (
          i.load(t),
          void 0 !== e && (Nt(e) || Xt(e) ? i.load({ value: e }) : i.load(e)),
          i
        );
      }
      load(t) {
        Yt(t) || Yt(t.value) || (this.value = t.value);
      }
    }
    class rs {
      constructor() {
        (this.color = new as()),
          (this.color.value = ""),
          (this.image = ""),
          (this.position = ""),
          (this.repeat = ""),
          (this.size = ""),
          (this.opacity = 1);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.color && (this.color = as.create(this.color, t.color)),
          void 0 !== t.image && (this.image = t.image),
          void 0 !== t.position && (this.position = t.position),
          void 0 !== t.repeat && (this.repeat = t.repeat),
          void 0 !== t.size && (this.size = t.size),
          void 0 !== t.opacity && (this.opacity = t.opacity));
      }
    }
    class cs {
      constructor() {
        this.opacity = 1;
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.color && (this.color = as.create(this.color, t.color)),
          void 0 !== t.image && (this.image = t.image),
          void 0 !== t.opacity && (this.opacity = t.opacity));
      }
    }
    class ls {
      constructor() {
        (this.composite = "destination-out"),
          (this.cover = new cs()),
          (this.enable = !1);
      }
      load(t) {
        if (!Yt(t)) {
          if (
            (void 0 !== t.composite && (this.composite = t.composite),
            void 0 !== t.cover)
          ) {
            const e = t.cover,
              i = Nt(t.cover) ? { color: t.cover } : t.cover;
            this.cover.load(
              void 0 !== e.color || void 0 !== e.image ? e : { color: i }
            );
          }
          void 0 !== t.enable && (this.enable = t.enable);
        }
      }
    }
    class hs {
      constructor() {
        (this.enable = !0), (this.zIndex = 0);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.enable && (this.enable = t.enable),
          void 0 !== t.zIndex && (this.zIndex = t.zIndex));
      }
    }
    class ds {
      constructor() {
        (this.enable = !1), (this.mode = []);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.enable && (this.enable = t.enable),
          void 0 !== t.mode && (this.mode = t.mode));
      }
    }
    !(function (t) {
      (t.circle = "circle"), (t.rectangle = "rectangle");
    })(fi || (fi = {}));
    class us {
      constructor() {
        (this.selectors = []),
          (this.enable = !1),
          (this.mode = []),
          (this.type = fi.circle);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.selectors && (this.selectors = t.selectors),
          void 0 !== t.enable && (this.enable = t.enable),
          void 0 !== t.mode && (this.mode = t.mode),
          void 0 !== t.type && (this.type = t.type));
      }
    }
    class ps {
      constructor() {
        (this.enable = !1), (this.force = 2), (this.smooth = 10);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.enable && (this.enable = t.enable),
          void 0 !== t.force && (this.force = t.force),
          void 0 !== t.smooth && (this.smooth = t.smooth));
      }
    }
    class fs {
      constructor() {
        (this.enable = !1), (this.mode = []), (this.parallax = new ps());
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.enable && (this.enable = t.enable),
          void 0 !== t.mode && (this.mode = t.mode),
          this.parallax.load(t.parallax));
      }
    }
    class ms {
      constructor() {
        (this.delay = 0.5), (this.enable = !0);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.delay && (this.delay = t.delay),
          void 0 !== t.enable && (this.enable = t.enable));
      }
    }
    class vs {
      constructor() {
        (this.onClick = new ds()),
          (this.onDiv = new us()),
          (this.onHover = new fs()),
          (this.resize = new ms());
      }
      load(t) {
        if (Yt(t)) return;
        this.onClick.load(t.onClick);
        const e = t.onDiv;
        void 0 !== e &&
          (this.onDiv = ei(e, (t) => {
            const e = new us();
            return e.load(t), e;
          })),
          this.onHover.load(t.onHover),
          this.resize.load(t.resize);
      }
    }
    class ys {
      constructor(t, e) {
        (this._engine = t), (this._container = e);
      }
      load(t) {
        if (Yt(t)) return;
        if (!this._container) return;
        const e = this._engine.interactors.get(this._container);
        if (e)
          for (const i of e) i.loadModeOptions && i.loadModeOptions(this, t);
      }
    }
    class gs {
      constructor(t, e) {
        (this.detectsOn = ui.window),
          (this.events = new vs()),
          (this.modes = new ys(t, e));
      }
      load(t) {
        if (Yt(t)) return;
        const e = t.detectsOn;
        void 0 !== e && (this.detectsOn = e),
          this.events.load(t.events),
          this.modes.load(t.modes);
      }
    }
    class ws {
      load(t) {
        Yt(t) ||
          (t.position &&
            (this.position = {
              x: t.position.x ?? kt,
              y: t.position.y ?? kt,
              mode: t.position.mode ?? Se.percent,
            }),
          t.options && (this.options = je({}, t.options)));
      }
    }
    !(function (t) {
      (t.screen = "screen"), (t.canvas = "canvas");
    })(mi || (mi = {}));
    class _s {
      constructor() {
        (this.maxWidth = 1 / 0), (this.options = {}), (this.mode = mi.canvas);
      }
      load(t) {
        Yt(t) ||
          (Yt(t.maxWidth) || (this.maxWidth = t.maxWidth),
          Yt(t.mode) ||
            (t.mode === mi.screen
              ? (this.mode = mi.screen)
              : (this.mode = mi.canvas)),
          Yt(t.options) || (this.options = je({}, t.options)));
      }
    }
    !(function (t) {
      (t.any = "any"), (t.dark = "dark"), (t.light = "light");
    })(vi || (vi = {}));
    class bs {
      constructor() {
        (this.auto = !1), (this.mode = vi.any), (this.value = !1);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.auto && (this.auto = t.auto),
          void 0 !== t.mode && (this.mode = t.mode),
          void 0 !== t.value && (this.value = t.value));
      }
    }
    class xs {
      constructor() {
        (this.name = ""), (this.default = new bs());
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.name && (this.name = t.name),
          this.default.load(t.default),
          void 0 !== t.options && (this.options = je({}, t.options)));
      }
    }
    class zs {
      constructor() {
        (this.count = 0),
          (this.enable = !1),
          (this.speed = 1),
          (this.decay = 0),
          (this.delay = 0),
          (this.sync = !1);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.count && (this.count = ue(t.count)),
          void 0 !== t.enable && (this.enable = t.enable),
          void 0 !== t.speed && (this.speed = ue(t.speed)),
          void 0 !== t.decay && (this.decay = ue(t.decay)),
          void 0 !== t.delay && (this.delay = ue(t.delay)),
          void 0 !== t.sync && (this.sync = t.sync));
      }
    }
    class Ms extends zs {
      constructor() {
        super(), (this.mode = Pe.auto), (this.startValue = De.random);
      }
      load(t) {
        super.load(t),
          Yt(t) ||
            (void 0 !== t.mode && (this.mode = t.mode),
            void 0 !== t.startValue && (this.startValue = t.startValue));
      }
    }
    class Ps extends zs {
      constructor() {
        super(), (this.offset = 0), (this.sync = !0);
      }
      load(t) {
        super.load(t),
          Yt(t) || (void 0 !== t.offset && (this.offset = ue(t.offset)));
      }
    }
    class Cs {
      constructor() {
        (this.h = new Ps()), (this.s = new Ps()), (this.l = new Ps());
      }
      load(t) {
        Yt(t) || (this.h.load(t.h), this.s.load(t.s), this.l.load(t.l));
      }
    }
    class Os extends as {
      constructor() {
        super(), (this.animation = new Cs());
      }
      static create(t, e) {
        const i = new Os();
        return (
          i.load(t),
          void 0 !== e && (Nt(e) || Xt(e) ? i.load({ value: e }) : i.load(e)),
          i
        );
      }
      load(t) {
        if ((super.load(t), Yt(t))) return;
        const e = t.animation;
        void 0 !== e &&
          (void 0 !== e.enable
            ? this.animation.h.load(e)
            : this.animation.load(t.animation));
      }
    }
    !(function (t) {
      (t.absorb = "absorb"), (t.bounce = "bounce"), (t.destroy = "destroy");
    })(yi || (yi = {}));
    class ks {
      constructor() {
        this.speed = 2;
      }
      load(t) {
        Yt(t) || (void 0 !== t.speed && (this.speed = t.speed));
      }
    }
    class Ss {
      constructor() {
        (this.enable = !0), (this.retries = 0);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.enable && (this.enable = t.enable),
          void 0 !== t.retries && (this.retries = t.retries));
      }
    }
    class Ds {
      constructor() {
        this.value = 0;
      }
      load(t) {
        Yt(t) || Yt(t.value) || (this.value = ue(t.value));
      }
    }
    class Rs extends Ds {
      constructor() {
        super(), (this.animation = new zs());
      }
      load(t) {
        if ((super.load(t), Yt(t))) return;
        const e = t.animation;
        void 0 !== e && this.animation.load(e);
      }
    }
    class Es extends Rs {
      constructor() {
        super(), (this.animation = new Ms());
      }
      load(t) {
        super.load(t);
      }
    }
    class Ts extends Ds {
      constructor() {
        super(), (this.value = 1);
      }
    }
    class Is {
      constructor() {
        (this.horizontal = new Ts()), (this.vertical = new Ts());
      }
      load(t) {
        Yt(t) ||
          (this.horizontal.load(t.horizontal), this.vertical.load(t.vertical));
      }
    }
    class Ls {
      constructor() {
        (this.absorb = new ks()),
          (this.bounce = new Is()),
          (this.enable = !1),
          (this.maxSpeed = 50),
          (this.mode = yi.bounce),
          (this.overlap = new Ss());
      }
      load(t) {
        Yt(t) ||
          (this.absorb.load(t.absorb),
          this.bounce.load(t.bounce),
          void 0 !== t.enable && (this.enable = t.enable),
          void 0 !== t.maxSpeed && (this.maxSpeed = ue(t.maxSpeed)),
          void 0 !== t.mode && (this.mode = t.mode),
          this.overlap.load(t.overlap));
      }
    }
    class Fs {
      constructor() {
        (this.close = !0),
          (this.fill = !0),
          (this.options = {}),
          (this.type = []);
      }
      load(t) {
        if (Yt(t)) return;
        const e = t.options;
        if (void 0 !== e)
          for (const t in e) {
            const i = e[t];
            i && (this.options[t] = je(this.options[t] ?? {}, i));
          }
        void 0 !== t.close && (this.close = t.close),
          void 0 !== t.fill && (this.fill = t.fill),
          void 0 !== t.type && (this.type = t.type);
      }
    }
    class As {
      constructor() {
        (this.offset = 0), (this.value = 90);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.offset && (this.offset = ue(t.offset)),
          void 0 !== t.value && (this.value = ue(t.value)));
      }
    }
    class Vs {
      constructor() {
        (this.distance = 200),
          (this.enable = !1),
          (this.rotate = { x: 3e3, y: 3e3 });
      }
      load(t) {
        if (
          !Yt(t) &&
          (void 0 !== t.distance && (this.distance = ue(t.distance)),
          void 0 !== t.enable && (this.enable = t.enable),
          t.rotate)
        ) {
          const e = t.rotate.x;
          void 0 !== e && (this.rotate.x = e);
          const i = t.rotate.y;
          void 0 !== i && (this.rotate.y = i);
        }
      }
    }
    class Bs {
      constructor() {
        (this.x = 50),
          (this.y = 50),
          (this.mode = Se.percent),
          (this.radius = 0);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.x && (this.x = t.x),
          void 0 !== t.y && (this.y = t.y),
          void 0 !== t.mode && (this.mode = t.mode),
          void 0 !== t.radius && (this.radius = t.radius));
      }
    }
    class Us {
      constructor() {
        (this.acceleration = 9.81),
          (this.enable = !1),
          (this.inverse = !1),
          (this.maxSpeed = 50);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.acceleration &&
            (this.acceleration = ue(t.acceleration)),
          void 0 !== t.enable && (this.enable = t.enable),
          void 0 !== t.inverse && (this.inverse = t.inverse),
          void 0 !== t.maxSpeed && (this.maxSpeed = ue(t.maxSpeed)));
      }
    }
    class Ws {
      constructor() {
        (this.clamp = !0),
          (this.delay = new Ds()),
          (this.enable = !1),
          (this.options = {});
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.clamp && (this.clamp = t.clamp),
          this.delay.load(t.delay),
          void 0 !== t.enable && (this.enable = t.enable),
          (this.generator = t.generator),
          t.options && (this.options = je(this.options, t.options)));
      }
    }
    class Hs {
      load(t) {
        Yt(t) ||
          (void 0 !== t.color && (this.color = as.create(this.color, t.color)),
          void 0 !== t.image && (this.image = t.image));
      }
    }
    class qs {
      constructor() {
        (this.enable = !1), (this.length = 10), (this.fill = new Hs());
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.enable && (this.enable = t.enable),
          void 0 !== t.fill && this.fill.load(t.fill),
          void 0 !== t.length && (this.length = t.length));
      }
    }
    !(function (t) {
      (t.bounce = "bounce"),
        (t.none = "none"),
        (t.out = "out"),
        (t.destroy = "destroy"),
        (t.split = "split");
    })(gi || (gi = {}));
    class Gs {
      constructor() {
        this.default = gi.out;
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.default && (this.default = t.default),
          (this.bottom = t.bottom ?? t.default),
          (this.left = t.left ?? t.default),
          (this.right = t.right ?? t.default),
          (this.top = t.top ?? t.default));
      }
    }
    class Ns {
      constructor() {
        (this.acceleration = 0), (this.enable = !1);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.acceleration &&
            (this.acceleration = ue(t.acceleration)),
          void 0 !== t.enable && (this.enable = t.enable),
          t.position && (this.position = je({}, t.position)));
      }
    }
    class $s {
      constructor() {
        (this.angle = new As()),
          (this.attract = new Vs()),
          (this.center = new Bs()),
          (this.decay = 0),
          (this.distance = {}),
          (this.direction = qt.none),
          (this.drift = 0),
          (this.enable = !1),
          (this.gravity = new Us()),
          (this.path = new Ws()),
          (this.outModes = new Gs()),
          (this.random = !1),
          (this.size = !1),
          (this.speed = 2),
          (this.spin = new Ns()),
          (this.straight = !1),
          (this.trail = new qs()),
          (this.vibrate = !1),
          (this.warp = !1);
      }
      load(t) {
        if (Yt(t)) return;
        this.angle.load($t(t.angle) ? { value: t.angle } : t.angle),
          this.attract.load(t.attract),
          this.center.load(t.center),
          void 0 !== t.decay && (this.decay = ue(t.decay)),
          void 0 !== t.direction && (this.direction = t.direction),
          void 0 !== t.distance &&
            (this.distance = $t(t.distance)
              ? { horizontal: t.distance, vertical: t.distance }
              : { ...t.distance }),
          void 0 !== t.drift && (this.drift = ue(t.drift)),
          void 0 !== t.enable && (this.enable = t.enable),
          this.gravity.load(t.gravity);
        const e = t.outModes;
        void 0 !== e &&
          (Qt(e) ? this.outModes.load(e) : this.outModes.load({ default: e })),
          this.path.load(t.path),
          void 0 !== t.random && (this.random = t.random),
          void 0 !== t.size && (this.size = t.size),
          void 0 !== t.speed && (this.speed = ue(t.speed)),
          this.spin.load(t.spin),
          void 0 !== t.straight && (this.straight = t.straight),
          this.trail.load(t.trail),
          void 0 !== t.vibrate && (this.vibrate = t.vibrate),
          void 0 !== t.warp && (this.warp = t.warp);
      }
    }
    class js extends Ms {
      constructor() {
        super(), (this.destroy = Oe.none), (this.speed = 2);
      }
      load(t) {
        super.load(t),
          Yt(t) || (void 0 !== t.destroy && (this.destroy = t.destroy));
      }
    }
    class Qs extends Es {
      constructor() {
        super(), (this.animation = new js()), (this.value = 1);
      }
      load(t) {
        if (Yt(t)) return;
        super.load(t);
        const e = t.animation;
        void 0 !== e && this.animation.load(e);
      }
    }
    class Xs {
      constructor() {
        (this.enable = !1), (this.width = 1920), (this.height = 1080);
      }
      load(t) {
        if (Yt(t)) return;
        void 0 !== t.enable && (this.enable = t.enable);
        const e = t.width;
        void 0 !== e && (this.width = e);
        const i = t.height;
        void 0 !== i && (this.height = i);
      }
    }
    !(function (t) {
      (t.delete = "delete"), (t.wait = "wait");
    })(wi || (wi = {}));
    class Ys {
      constructor() {
        (this.mode = wi.delete), (this.value = 0);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.mode && (this.mode = t.mode),
          void 0 !== t.value && (this.value = t.value));
      }
    }
    class Zs {
      constructor() {
        (this.density = new Xs()), (this.limit = new Ys()), (this.value = 0);
      }
      load(t) {
        Yt(t) ||
          (this.density.load(t.density),
          this.limit.load(t.limit),
          void 0 !== t.value && (this.value = t.value));
      }
    }
    class Js {
      constructor() {
        (this.blur = 0),
          (this.color = new as()),
          (this.enable = !1),
          (this.offset = { x: 0, y: 0 }),
          (this.color.value = "#000");
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.blur && (this.blur = t.blur),
          (this.color = as.create(this.color, t.color)),
          void 0 !== t.enable && (this.enable = t.enable),
          void 0 !== t.offset &&
            (void 0 !== t.offset.x && (this.offset.x = t.offset.x),
            void 0 !== t.offset.y && (this.offset.y = t.offset.y)));
      }
    }
    class Ks {
      constructor() {
        (this.close = !0),
          (this.fill = !0),
          (this.options = {}),
          (this.type = "circle");
      }
      load(t) {
        if (Yt(t)) return;
        const e = t.options;
        if (void 0 !== e)
          for (const t in e) {
            const i = e[t];
            i && (this.options[t] = je(this.options[t] ?? {}, i));
          }
        void 0 !== t.close && (this.close = t.close),
          void 0 !== t.fill && (this.fill = t.fill),
          void 0 !== t.type && (this.type = t.type);
      }
    }
    class to extends Ms {
      constructor() {
        super(), (this.destroy = Oe.none), (this.speed = 5);
      }
      load(t) {
        super.load(t),
          Yt(t) || (void 0 !== t.destroy && (this.destroy = t.destroy));
      }
    }
    class eo extends Es {
      constructor() {
        super(), (this.animation = new to()), (this.value = 3);
      }
      load(t) {
        if ((super.load(t), Yt(t))) return;
        const e = t.animation;
        void 0 !== e && this.animation.load(e);
      }
    }
    class io {
      constructor() {
        this.width = 0;
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.color && (this.color = Os.create(this.color, t.color)),
          void 0 !== t.width && (this.width = ue(t.width)),
          void 0 !== t.opacity && (this.opacity = ue(t.opacity)));
      }
    }
    class so extends Ds {
      constructor() {
        super(),
          (this.opacityRate = 1),
          (this.sizeRate = 1),
          (this.velocityRate = 1);
      }
      load(t) {
        super.load(t),
          Yt(t) ||
            (void 0 !== t.opacityRate && (this.opacityRate = t.opacityRate),
            void 0 !== t.sizeRate && (this.sizeRate = t.sizeRate),
            void 0 !== t.velocityRate && (this.velocityRate = t.velocityRate));
      }
    }
    class oo {
      constructor(t, e) {
        (this._engine = t),
          (this._container = e),
          (this.bounce = new Is()),
          (this.collisions = new Ls()),
          (this.color = new Os()),
          (this.color.value = "#fff"),
          (this.effect = new Fs()),
          (this.groups = {}),
          (this.move = new $s()),
          (this.number = new Zs()),
          (this.opacity = new Qs()),
          (this.reduceDuplicates = !1),
          (this.shadow = new Js()),
          (this.shape = new Ks()),
          (this.size = new eo()),
          (this.stroke = new io()),
          (this.zIndex = new so());
      }
      load(t) {
        if (Yt(t)) return;
        if (void 0 !== t.groups)
          for (const e of Object.keys(t.groups)) {
            if (!Object.hasOwn(t.groups, e)) continue;
            const i = t.groups[e];
            void 0 !== i && (this.groups[e] = je(this.groups[e] ?? {}, i));
          }
        void 0 !== t.reduceDuplicates &&
          (this.reduceDuplicates = t.reduceDuplicates),
          this.bounce.load(t.bounce),
          this.color.load(Os.create(this.color, t.color)),
          this.effect.load(t.effect),
          this.move.load(t.move),
          this.number.load(t.number),
          this.opacity.load(t.opacity),
          this.shape.load(t.shape),
          this.size.load(t.size),
          this.shadow.load(t.shadow),
          this.zIndex.load(t.zIndex),
          this.collisions.load(t.collisions),
          void 0 !== t.interactivity &&
            (this.interactivity = je({}, t.interactivity));
        const e = t.stroke;
        if (
          (e &&
            (this.stroke = ei(e, (t) => {
              const e = new io();
              return e.load(t), e;
            })),
          this._container)
        ) {
          const e = this._engine.updaters.get(this._container);
          if (e) for (const i of e) i.loadOptions && i.loadOptions(this, t);
          const i = this._engine.interactors.get(this._container);
          if (i)
            for (const e of i)
              e.loadParticlesOptions && e.loadParticlesOptions(this, t);
        }
      }
    }
    function no(t, ...e) {
      for (const i of e) t.load(i);
    }
    function ao(t, e, ...i) {
      const s = new oo(t, e);
      return no(s, ...i), s;
    }
    class ro {
      constructor(t, e) {
        (this._findDefaultTheme = (t) =>
          this.themes.find((e) => e.default.value && e.default.mode === t) ??
          this.themes.find(
            (t) => t.default.value && t.default.mode === vi.any
          )),
          (this._importPreset = (t) => {
            this.load(this._engine.getPreset(t));
          }),
          (this._engine = t),
          (this._container = e),
          (this.autoPlay = !0),
          (this.background = new rs()),
          (this.backgroundMask = new ls()),
          (this.clear = !0),
          (this.defaultThemes = {}),
          (this.delay = 0),
          (this.fullScreen = new hs()),
          (this.detectRetina = !0),
          (this.duration = 0),
          (this.fpsLimit = 120),
          (this.interactivity = new gs(t, e)),
          (this.manualParticles = []),
          (this.particles = ao(this._engine, this._container)),
          (this.pauseOnBlur = !0),
          (this.pauseOnOutsideViewport = !0),
          (this.responsive = []),
          (this.smooth = !1),
          (this.style = {}),
          (this.themes = []),
          (this.zLayers = 100);
      }
      load(t) {
        if (Yt(t)) return;
        void 0 !== t.preset && ei(t.preset, (t) => this._importPreset(t)),
          void 0 !== t.autoPlay && (this.autoPlay = t.autoPlay),
          void 0 !== t.clear && (this.clear = t.clear),
          void 0 !== t.key && (this.key = t.key),
          void 0 !== t.name && (this.name = t.name),
          void 0 !== t.delay && (this.delay = ue(t.delay));
        const e = t.detectRetina;
        void 0 !== e && (this.detectRetina = e),
          void 0 !== t.duration && (this.duration = ue(t.duration));
        const i = t.fpsLimit;
        void 0 !== i && (this.fpsLimit = i),
          void 0 !== t.pauseOnBlur && (this.pauseOnBlur = t.pauseOnBlur),
          void 0 !== t.pauseOnOutsideViewport &&
            (this.pauseOnOutsideViewport = t.pauseOnOutsideViewport),
          void 0 !== t.zLayers && (this.zLayers = t.zLayers),
          this.background.load(t.background);
        const s = t.fullScreen;
        Gt(s) ? (this.fullScreen.enable = s) : this.fullScreen.load(s),
          this.backgroundMask.load(t.backgroundMask),
          this.interactivity.load(t.interactivity),
          t.manualParticles &&
            (this.manualParticles = t.manualParticles.map((t) => {
              const e = new ws();
              return e.load(t), e;
            })),
          this.particles.load(t.particles),
          (this.style = je(this.style, t.style)),
          this._engine.loadOptions(this, t),
          void 0 !== t.smooth && (this.smooth = t.smooth);
        const o = this._engine.interactors.get(this._container);
        if (o) for (const e of o) e.loadOptions && e.loadOptions(this, t);
        if (void 0 !== t.responsive)
          for (const e of t.responsive) {
            const t = new _s();
            t.load(e), this.responsive.push(t);
          }
        if (
          (this.responsive.sort((t, e) => t.maxWidth - e.maxWidth),
          void 0 !== t.themes)
        )
          for (const e of t.themes) {
            const t = this.themes.find((t) => t.name === e.name);
            if (t) t.load(e);
            else {
              const t = new xs();
              t.load(e), this.themes.push(t);
            }
          }
        (this.defaultThemes.dark = this._findDefaultTheme(vi.dark)?.name),
          (this.defaultThemes.light = this._findDefaultTheme(vi.light)?.name);
      }
      setResponsive(t, e, i) {
        this.load(i);
        const s = this.responsive.find((i) =>
          i.mode === mi.screen && screen
            ? i.maxWidth > screen.availWidth
            : i.maxWidth * e > t
        );
        return this.load(s?.options), s?.maxWidth;
      }
      setTheme(t) {
        if (t) {
          const e = this.themes.find((e) => e.name === t);
          e && this.load(e.options);
        } else {
          const t = Ae("(prefers-color-scheme: dark)"),
            e = t?.matches,
            i = this._findDefaultTheme(e ? vi.dark : vi.light);
          i && this.load(i.options);
        }
      }
    }
    !(function (t) {
      (t.external = "external"), (t.particles = "particles");
    })(_i || (_i = {}));
    class co {
      constructor(t, e) {
        (this.container = e),
          (this._engine = t),
          (this._interactors = []),
          (this._externalInteractors = []),
          (this._particleInteractors = []);
      }
      externalInteract(t) {
        for (const e of this._externalInteractors)
          e.isEnabled() && e.interact(t);
      }
      handleClickMode(t) {
        for (const e of this._externalInteractors) e.handleClickMode?.(t);
      }
      async init() {
        (this._interactors = await this._engine.getInteractors(
          this.container,
          !0
        )),
          (this._externalInteractors = []),
          (this._particleInteractors = []);
        for (const t of this._interactors) {
          switch (t.type) {
            case _i.external:
              this._externalInteractors.push(t);
              break;
            case _i.particles:
              this._particleInteractors.push(t);
          }
          t.init();
        }
      }
      particlesInteract(t, e) {
        for (const i of this._externalInteractors) i.clear(t, e);
        for (const i of this._particleInteractors)
          i.isEnabled(t) && i.interact(t, e);
      }
      reset(t) {
        for (const e of this._externalInteractors) e.isEnabled() && e.reset(t);
        for (const e of this._particleInteractors) e.isEnabled(t) && e.reset(t);
      }
    }
    function lo(t) {
      if (!Ue(t.outMode, t.checkModes)) return;
      const e = t.radius * x;
      t.coord > t.maxCoord - e
        ? t.setCb(-t.radius)
        : t.coord < e && t.setCb(t.radius);
    }
    !(function (t) {
      (t.normal = "normal"), (t.inside = "inside"), (t.outside = "outside");
    })(bi || (bi = {}));
    class ho {
      constructor(t, e) {
        (this.container = e),
          (this._calcPosition = (t, e, i, s = S) => {
            for (const s of t.plugins.values()) {
              const t =
                void 0 !== s.particlePosition
                  ? s.particlePosition(e, this)
                  : void 0;
              if (t) return Zt.create(t.x, t.y, i);
            }
            const o = xe({ size: t.canvas.size, position: e }),
              n = Zt.create(o.x, o.y, i),
              a = this.getRadius(),
              r = this.options.move.outModes,
              c = (e) => {
                lo({
                  outMode: e,
                  checkModes: [gi.bounce],
                  coord: n.x,
                  maxCoord: t.canvas.size.width,
                  setCb: (t) => (n.x += t),
                  radius: a,
                });
              },
              l = (e) => {
                lo({
                  outMode: e,
                  checkModes: [gi.bounce],
                  coord: n.y,
                  maxCoord: t.canvas.size.height,
                  setCb: (t) => (n.y += t),
                  radius: a,
                });
              };
            return (
              c(r.left ?? r.default),
              c(r.right ?? r.default),
              l(r.top ?? r.default),
              l(r.bottom ?? r.default),
              this._checkOverlap(n, s)
                ? this._calcPosition(t, void 0, i, s + ut)
                : n
            );
          }),
          (this._calculateVelocity = () => {
            const t = ye(this.direction).copy(),
              e = this.options.move;
            if (e.direction === qt.inside || e.direction === qt.outside)
              return t;
            const i = me(le(e.angle.value)),
              s = me(le(e.angle.offset)),
              o = { left: s - i * v, right: s + i * v };
            return (
              e.straight || (t.angle += ce(ue(o.left, o.right))),
              e.random && "number" == typeof e.speed && (t.length *= ie()),
              t
            );
          }),
          (this._checkOverlap = (t, e = S) => {
            const i = this.options.collisions,
              s = this.getRadius();
            if (!i.enable) return !1;
            const o = i.overlap;
            if (o.enable) return !1;
            const n = o.retries;
            if (n >= pt && e > n)
              throw new Error(
                `${f} particle is overlapping and can't be placed`
              );
            return !!this.container.particles.find(
              (e) => fe(t, e.position) < s + e.getRadius()
            );
          }),
          (this._getRollColor = (t) => {
            if (!t || !this.roll || (!this.backColor && !this.roll.alter))
              return t;
            const e = this.roll.horizontal && this.roll.vertical ? x * ft : ft,
              i = this.roll.horizontal ? Math.PI * v : ht;
            return Math.floor(((this.roll.angle ?? ht) + i) / (Math.PI / e)) % x
              ? this.backColor
                ? this.backColor
                : this.roll.alter
                ? ts(t, this.roll.alter.type, this.roll.alter.value)
                : t
              : t;
          }),
          (this._initPosition = (t) => {
            const e = this.container,
              i = le(this.options.zIndex.value);
            (this.position = this._calcPosition(e, t, ae(i, mt, e.zLayers))),
              (this.initialPosition = this.position.copy());
            const s = e.canvas.size;
            switch (
              ((this.moveCenter = {
                ...ai(this.options.move.center, s),
                radius: this.options.move.center.radius ?? vt,
                mode: this.options.move.center.mode ?? Se.percent,
              }),
              (this.direction = ve(
                this.options.move.direction,
                this.position,
                this.moveCenter
              )),
              this.options.move.direction)
            ) {
              case qt.inside:
                this.outType = bi.inside;
                break;
              case qt.outside:
                this.outType = bi.outside;
            }
            this.offset = Jt.origin;
          }),
          (this._engine = t);
      }
      destroy(t) {
        if (this.unbreakable || this.destroyed) return;
        (this.destroyed = !0),
          (this.bubble.inRange = !1),
          (this.slow.inRange = !1);
        const e = this.container,
          i = this.pathGenerator,
          s = e.shapeDrawers.get(this.shape);
        s?.particleDestroy?.(this);
        for (const i of e.plugins.values()) i.particleDestroyed?.(this, t);
        for (const i of e.particles.updaters) i.particleDestroyed?.(this, t);
        i?.reset(this),
          this._engine.dispatchEvent(pi.particleDestroyed, {
            container: this.container,
            data: { particle: this },
          });
      }
      draw(t) {
        const e = this.container,
          i = e.canvas;
        for (const s of e.plugins.values()) i.drawParticlePlugin(s, this, t);
        i.drawParticle(this, t);
      }
      getFillColor() {
        return this._getRollColor(this.bubble.color ?? Bi(this.color));
      }
      getMass() {
        return this.getRadius() ** D * Math.PI * v;
      }
      getPosition() {
        return {
          x: this.position.x + this.offset.x,
          y: this.position.y + this.offset.y,
          z: this.position.z,
        };
      }
      getRadius() {
        return this.bubble.radius ?? this.size.value;
      }
      getStrokeColor() {
        return this._getRollColor(this.bubble.color ?? Bi(this.strokeColor));
      }
      init(t, e, i, s) {
        const o = this.container,
          n = this._engine;
        (this.id = t),
          (this.group = s),
          (this.effectClose = !0),
          (this.effectFill = !0),
          (this.shapeClose = !0),
          (this.shapeFill = !0),
          (this.pathRotation = !1),
          (this.lastPathTime = 0),
          (this.destroyed = !1),
          (this.unbreakable = !1),
          (this.isRotating = !1),
          (this.rotation = 0),
          (this.misplaced = !1),
          (this.retina = { maxDistance: {} }),
          (this.outType = bi.normal),
          (this.ignoresResizeRatio = !0);
        const a = o.retina.pixelRatio,
          r = o.actualOptions,
          c = ao(this._engine, o, r.particles),
          { reduceDuplicates: l } = c,
          h = c.effect.type,
          d = c.shape.type;
        (this.effect = ii(h, this.id, l)), (this.shape = ii(d, this.id, l));
        const u = c.effect,
          p = c.shape;
        if (i) {
          if (i.effect?.type) {
            const t = ii(i.effect.type, this.id, l);
            t && ((this.effect = t), u.load(i.effect));
          }
          if (i.shape?.type) {
            const t = ii(i.shape.type, this.id, l);
            t && ((this.shape = t), p.load(i.shape));
          }
        }
        if (this.effect === _) {
          const t = [...this.container.effectDrawers.keys()];
          this.effect = t[Math.floor(Math.random() * t.length)];
        }
        if (this.shape === _) {
          const t = [...this.container.shapeDrawers.keys()];
          this.shape = t[Math.floor(Math.random() * t.length)];
        }
        (this.effectData = (function (t, e, i, s) {
          const o = e.options[t];
          if (o) return je({ close: e.close, fill: e.fill }, ii(o, i, s));
        })(this.effect, u, this.id, l)),
          (this.shapeData = (function (t, e, i, s) {
            const o = e.options[t];
            if (o) return je({ close: e.close, fill: e.fill }, ii(o, i, s));
          })(this.shape, p, this.id, l)),
          c.load(i);
        const f = this.effectData;
        f && c.load(f.particles);
        const m = this.shapeData;
        m && c.load(m.particles);
        const v = new gs(n, o);
        v.load(o.actualOptions.interactivity),
          v.load(c.interactivity),
          (this.interactivity = v),
          (this.effectFill = f?.fill ?? c.effect.fill),
          (this.effectClose = f?.close ?? c.effect.close),
          (this.shapeFill = m?.fill ?? c.shape.fill),
          (this.shapeClose = m?.close ?? c.shape.close),
          (this.options = c);
        const g = this.options.move.path;
        (this.pathDelay = le(g.delay.value) * y),
          g.generator &&
            ((this.pathGenerator = this._engine.getPathGenerator(g.generator)),
            this.pathGenerator &&
              o.addPath(g.generator, this.pathGenerator) &&
              this.pathGenerator.init(o)),
          o.retina.initParticle(this),
          (this.size = oi(this.options.size, a)),
          (this.bubble = { inRange: !1 }),
          (this.slow = { inRange: !1, factor: 1 }),
          this._initPosition(e),
          (this.initialVelocity = this._calculateVelocity()),
          (this.velocity = this.initialVelocity.copy()),
          (this.moveDecay = dt - le(this.options.move.decay));
        const w = o.particles;
        w.setLastZIndex(this.position.z),
          (this.zIndexFactor = this.position.z / o.zLayers),
          (this.sides = 24);
        let b = o.effectDrawers.get(this.effect);
        b ||
          ((b = this._engine.getEffectDrawer(this.effect)),
          b && o.effectDrawers.set(this.effect, b)),
          b?.loadEffect && b.loadEffect(this);
        let x = o.shapeDrawers.get(this.shape);
        x ||
          ((x = this._engine.getShapeDrawer(this.shape)),
          x && o.shapeDrawers.set(this.shape, x)),
          x?.loadShape && x.loadShape(this);
        const z = x?.getSidesCount;
        z && (this.sides = z(this)),
          (this.spawning = !1),
          (this.shadowColor = Mi(this._engine, this.options.shadow.color));
        for (const t of w.updaters) t.init(this);
        for (const t of w.movers) t.init?.(this);
        b?.particleInit?.(o, this), x?.particleInit?.(o, this);
        for (const t of o.plugins.values()) t.particleCreated?.(this);
      }
      isInsideCanvas() {
        const t = this.getRadius(),
          e = this.container.canvas.size,
          i = this.position;
        return (
          i.x >= -t && i.y >= -t && i.y <= e.height + t && i.x <= e.width + t
        );
      }
      isVisible() {
        return !this.destroyed && !this.spawning && this.isInsideCanvas();
      }
      reset() {
        for (const t of this.container.particles.updaters) t.reset?.(this);
      }
    }
    class uo {
      constructor(t, e) {
        (this.position = t), (this.particle = e);
      }
    }
    !(function (t) {
      (t.circle = "circle"), (t.rectangle = "rectangle");
    })(xi || (xi = {}));
    class po {
      constructor(t, e, i) {
        (this.position = { x: t, y: e }), (this.type = i);
      }
    }
    class fo extends po {
      constructor(t, e, i) {
        super(t, e, xi.circle), (this.radius = i);
      }
      contains(t) {
        return fe(t, this.position) <= this.radius;
      }
      intersects(t) {
        const e = this.position,
          i = t.position,
          s = Math.abs(i.x - e.x),
          o = Math.abs(i.y - e.y),
          n = this.radius;
        if (t instanceof fo || t.type === xi.circle) {
          return n + t.radius > Math.sqrt(s ** D + o ** D);
        }
        if (t instanceof mo || t.type === xi.rectangle) {
          const e = t,
            { width: i, height: a } = e.size;
          return (
            Math.pow(s - i, D) + Math.pow(o - a, D) <= n ** D ||
            (s <= n + i && o <= n + a) ||
            s <= i ||
            o <= a
          );
        }
        return !1;
      }
    }
    class mo extends po {
      constructor(t, e, i, s) {
        super(t, e, xi.rectangle), (this.size = { height: s, width: i });
      }
      contains(t) {
        const e = this.size.width,
          i = this.size.height,
          s = this.position;
        return t.x >= s.x && t.x <= s.x + e && t.y >= s.y && t.y <= s.y + i;
      }
      intersects(t) {
        if (t instanceof fo) return t.intersects(this);
        const e = this.size.width,
          i = this.size.height,
          s = this.position,
          o = t.position,
          n = t instanceof mo ? t.size : { width: 0, height: 0 },
          a = n.width,
          r = n.height;
        return o.x < s.x + e && o.x + a > s.x && o.y < s.y + i && o.y + r > s.y;
      }
    }
    class vo {
      constructor(t, e) {
        (this.rectangle = t),
          (this.capacity = e),
          (this._subdivide = () => {
            const { x: t, y: e } = this.rectangle.position,
              { width: i, height: s } = this.rectangle.size,
              { capacity: o } = this;
            for (let n = 0; n < L; n++) {
              const a = n % x;
              this._subs.push(
                new vo(
                  new mo(
                    t + i * v * a,
                    e + s * v * (Math.round(n * v) - a),
                    i * v,
                    s * v
                  ),
                  o
                )
              );
            }
            this._divided = !0;
          }),
          (this._points = []),
          (this._divided = !1),
          (this._subs = []);
      }
      insert(t) {
        return (
          !!this.rectangle.contains(t.position) &&
          (this._points.length < this.capacity
            ? (this._points.push(t), !0)
            : (this._divided || this._subdivide(),
              this._subs.some((e) => e.insert(t))))
        );
      }
      query(t, e) {
        const i = [];
        if (!t.intersects(this.rectangle)) return [];
        for (const s of this._points)
          (!t.contains(s.position) &&
            fe(t.position, s.position) > s.particle.getRadius() &&
            (!e || e(s.particle))) ||
            i.push(s.particle);
        if (this._divided) for (const s of this._subs) i.push(...s.query(t, e));
        return i;
      }
      queryCircle(t, e, i) {
        return this.query(new fo(t.x, t.y, e), i);
      }
      queryRectangle(t, e, i) {
        return this.query(new mo(t.x, t.y, e.width, e.height), i);
      }
    }
    const yo = (t) => {
      const { height: e, width: i } = t;
      return new mo(yt * i, yt * e, gt * i, gt * e);
    };
    class go {
      constructor(t, e) {
        (this._addToPool = (...t) => {
          this._pool.push(...t);
        }),
          (this._applyDensity = (t, e, i) => {
            const s = t.number;
            if (!t.number.density?.enable)
              return void (void 0 === i
                ? (this._limit = s.limit.value)
                : s.limit && this._groupLimits.set(i, s.limit.value));
            const o = this._initDensityFactor(s.density),
              n = s.value,
              a = s.limit.value > wt ? s.limit.value : n,
              r = Math.min(n, a) * o + e,
              c = Math.min(
                this.count,
                this.filter((t) => t.group === i).length
              );
            void 0 === i
              ? (this._limit = s.limit.value * o)
              : this._groupLimits.set(i, s.limit.value * o),
              c < r
                ? this.push(Math.abs(r - c), void 0, t, i)
                : c > r && this.removeQuantity(c - r, i);
          }),
          (this._initDensityFactor = (t) => {
            const e = this._container;
            if (!e.canvas.element || !t.enable) return Pt;
            const i = e.canvas.element,
              s = e.retina.pixelRatio;
            return (i.width * i.height) / (t.height * t.width * s ** D);
          }),
          (this._pushParticle = (t, e, i, s) => {
            try {
              let o = this._pool.pop();
              o || (o = new ho(this._engine, this._container)),
                o.init(this._nextId, t, e, i);
              let n = !0;
              if ((s && (n = s(o)), !n)) return;
              return (
                this._array.push(o),
                this._zArray.push(o),
                this._nextId++,
                this._engine.dispatchEvent(pi.particleAdded, {
                  container: this._container,
                  data: { particle: o },
                }),
                o
              );
            } catch (t) {
              Te().warning(`${f} adding particle: ${t}`);
            }
          }),
          (this._removeParticle = (t, e, i) => {
            const s = this._array[t];
            if (!s || s.group !== e) return !1;
            const o = this._zArray.indexOf(s);
            return (
              this._array.splice(t, Ct),
              this._zArray.splice(o, Ct),
              s.destroy(i),
              this._engine.dispatchEvent(pi.particleRemoved, {
                container: this._container,
                data: { particle: s },
              }),
              this._addToPool(s),
              !0
            );
          }),
          (this._engine = t),
          (this._container = e),
          (this._nextId = 0),
          (this._array = []),
          (this._zArray = []),
          (this._pool = []),
          (this._limit = 0),
          (this._groupLimits = new Map()),
          (this._needsSort = !1),
          (this._lastZIndex = 0),
          (this._interactionManager = new co(t, e)),
          (this._pluginsInitialized = !1);
        const i = e.canvas.size;
        (this.quadTree = new vo(yo(i), R)),
          (this.movers = []),
          (this.updaters = []);
      }
      get count() {
        return this._array.length;
      }
      addManualParticles() {
        const t = this._container;
        t.actualOptions.manualParticles.forEach((e) =>
          this.addParticle(
            e.position ? ai(e.position, t.canvas.size) : void 0,
            e.options
          )
        );
      }
      addParticle(t, e, i, s) {
        const o = this._container.actualOptions.particles.number.limit.mode,
          n =
            void 0 === i
              ? this._limit
              : this._groupLimits.get(i) ?? this._limit,
          a = this.count;
        if (n > wt)
          switch (o) {
            case wi.delete: {
              const t = a + _t - n;
              t > bt && this.removeQuantity(t);
              break;
            }
            case wi.wait:
              if (a >= n) return;
          }
        return this._pushParticle(t, e, i, s);
      }
      clear() {
        (this._array = []),
          (this._zArray = []),
          (this._pluginsInitialized = !1);
      }
      destroy() {
        (this._array = []),
          (this._zArray = []),
          (this.movers = []),
          (this.updaters = []);
      }
      draw(t) {
        const e = this._container,
          i = e.canvas;
        i.clear(), this.update(t);
        for (const s of e.plugins.values()) i.drawPlugin(s, t);
        for (const e of this._zArray) e.draw(t);
      }
      filter(t) {
        return this._array.filter(t);
      }
      find(t) {
        return this._array.find(t);
      }
      get(t) {
        return this._array[t];
      }
      handleClickMode(t) {
        this._interactionManager.handleClickMode(t);
      }
      async init() {
        const t = this._container,
          e = t.actualOptions;
        (this._lastZIndex = 0),
          (this._needsSort = !1),
          await this.initPlugins();
        let i = !1;
        for (const e of t.plugins.values())
          if (((i = e.particlesInitialization?.() ?? i), i)) break;
        if ((this.addManualParticles(), !i)) {
          const t = e.particles,
            i = t.groups;
          for (const e in i) {
            const s = i[e];
            for (
              let i = this.count, o = 0;
              o < s.number?.value && i < t.number.value;
              i++, o++
            )
              this.addParticle(void 0, s, e);
          }
          for (let e = this.count; e < t.number.value; e++) this.addParticle();
        }
      }
      async initPlugins() {
        if (this._pluginsInitialized) return;
        const t = this._container;
        (this.movers = await this._engine.getMovers(t, !0)),
          (this.updaters = await this._engine.getUpdaters(t, !0)),
          await this._interactionManager.init();
        for (const e of t.pathGenerators.values()) e.init(t);
      }
      push(t, e, i, s) {
        for (let o = 0; o < t; o++) this.addParticle(e?.position, i, s);
      }
      async redraw() {
        this.clear(), await this.init(), this.draw({ value: 0, factor: 0 });
      }
      remove(t, e, i) {
        this.removeAt(this._array.indexOf(t), void 0, e, i);
      }
      removeAt(t, e = E, i, s) {
        if (t < xt || t > this.count) return;
        let o = 0;
        for (let n = t; o < e && n < this.count; n++)
          this._removeParticle(n, i, s) && (n--, o++);
      }
      removeQuantity(t, e) {
        this.removeAt(xt, t, e);
      }
      setDensity() {
        const t = this._container.actualOptions,
          e = t.particles.groups;
        for (const t in e) this._applyDensity(e[t], zt, t);
        this._applyDensity(t.particles, t.manualParticles.length);
      }
      setLastZIndex(t) {
        (this._lastZIndex = t),
          (this._needsSort = this._needsSort || this._lastZIndex < t);
      }
      setResizeFactor(t) {
        this._resizeFactor = t;
      }
      update(t) {
        const e = this._container,
          i = new Set();
        this.quadTree = new vo(yo(e.canvas.size), R);
        for (const t of e.pathGenerators.values()) t.update();
        for (const i of e.plugins.values()) i.update?.(t);
        const s = this._resizeFactor;
        for (const e of this._array) {
          s &&
            !e.ignoresResizeRatio &&
            ((e.position.x *= s.width),
            (e.position.y *= s.height),
            (e.initialPosition.x *= s.width),
            (e.initialPosition.y *= s.height)),
            (e.ignoresResizeRatio = !1),
            this._interactionManager.reset(e);
          for (const i of this._container.plugins.values()) {
            if (e.destroyed) break;
            i.particleUpdate?.(e, t);
          }
          for (const i of this.movers) i.isEnabled(e) && i.move(e, t);
          e.destroyed
            ? i.add(e)
            : this.quadTree.insert(new uo(e.getPosition(), e));
        }
        if (i.size) {
          const t = (t) => !i.has(t);
          (this._array = this.filter(t)),
            (this._zArray = this._zArray.filter(t));
          for (const t of i)
            this._engine.dispatchEvent(pi.particleRemoved, {
              container: this._container,
              data: { particle: t },
            });
          this._addToPool(...i);
        }
        this._interactionManager.externalInteract(t);
        for (const e of this._array) {
          for (const i of this.updaters) i.update(e, t);
          e.destroyed ||
            e.spawning ||
            this._interactionManager.particlesInteract(e, t);
        }
        if ((delete this._resizeFactor, this._needsSort)) {
          const t = this._zArray;
          t.sort((t, e) => e.position.z - t.position.z || t.id - e.id),
            (this._lastZIndex = t[t.length - Mt].position.z),
            (this._needsSort = !1);
        }
      }
    }
    class wo {
      constructor(t) {
        (this.container = t), (this.pixelRatio = T), (this.reduceFactor = I);
      }
      init() {
        const t = this.container,
          e = t.actualOptions;
        (this.pixelRatio =
          !e.detectRetina || Le() ? T : window.devicePixelRatio),
          (this.reduceFactor = I);
        const i = this.pixelRatio,
          s = t.canvas;
        if (s.element) {
          const t = s.element;
          (s.size.width = t.offsetWidth * i),
            (s.size.height = t.offsetHeight * i);
        }
        const o = e.particles,
          n = o.move;
        (this.maxSpeed = le(n.gravity.maxSpeed) * i),
          (this.sizeAnimationSpeed = le(o.size.animation.speed) * i);
      }
      initParticle(t) {
        const e = t.options,
          i = this.pixelRatio,
          s = e.move,
          o = s.distance,
          n = t.retina;
        (n.moveDrift = le(s.drift) * i),
          (n.moveSpeed = le(s.speed) * i),
          (n.sizeAnimationSpeed = le(e.size.animation.speed) * i);
        const a = n.maxDistance;
        (a.horizontal = void 0 !== o.horizontal ? o.horizontal * i : void 0),
          (a.vertical = void 0 !== o.vertical ? o.vertical * i : void 0),
          (n.maxSpeed = le(s.gravity.maxSpeed) * i);
      }
    }
    function _o(t) {
      return t && !t.destroyed;
    }
    function bo(t, e, ...i) {
      const s = new ro(t, e);
      return no(s, ...i), s;
    }
    class xo {
      constructor(t, e, i) {
        (this._intersectionManager = (t) => {
          if (_o(this) && this.actualOptions.pauseOnOutsideViewport)
            for (const e of t)
              e.target === this.interactivity.element &&
                (e.isIntersecting ? this.play() : this.pause());
        }),
          (this._nextFrame = (t) => {
            try {
              if (
                !this._smooth &&
                void 0 !== this._lastFrameTime &&
                t < this._lastFrameTime + y / this.fpsLimit
              )
                return void this.draw(!1);
              this._lastFrameTime ??= t;
              const e = (function (t, e = M, i = !1) {
                return { value: t, factor: i ? M / e : (M * t) / y };
              })(t - this._lastFrameTime, this.fpsLimit, this._smooth);
              if (
                (this.addLifeTime(e.value),
                (this._lastFrameTime = t),
                e.value > y)
              )
                return void this.draw(!1);
              if ((this.particles.draw(e), !this.alive()))
                return void this.destroy();
              this.animationStatus && this.draw(!1);
            } catch (t) {
              Te().error(`${f} in animation loop`, t);
            }
          }),
          (this._engine = t),
          (this.id = Symbol(e)),
          (this.fpsLimit = 120),
          (this._smooth = !1),
          (this._delay = 0),
          (this._duration = 0),
          (this._lifeTime = 0),
          (this._firstStart = !0),
          (this.started = !1),
          (this.destroyed = !1),
          (this._paused = !0),
          (this._lastFrameTime = 0),
          (this.zLayers = 100),
          (this.pageHidden = !1),
          (this._clickHandlers = new Map()),
          (this._sourceOptions = i),
          (this._initialSourceOptions = i),
          (this.retina = new wo(this)),
          (this.canvas = new ss(this, this._engine)),
          (this.particles = new go(this._engine, this)),
          (this.pathGenerators = new Map()),
          (this.interactivity = { mouse: { clicking: !1, inside: !1 } }),
          (this.plugins = new Map()),
          (this.effectDrawers = new Map()),
          (this.shapeDrawers = new Map()),
          (this._options = bo(this._engine, this)),
          (this.actualOptions = bo(this._engine, this)),
          (this._eventListeners = new ns(this)),
          (this._intersectionObserver = Ve((t) =>
            this._intersectionManager(t)
          )),
          this._engine.dispatchEvent(pi.containerBuilt, { container: this });
      }
      get animationStatus() {
        return !this._paused && !this.pageHidden && _o(this);
      }
      get options() {
        return this._options;
      }
      get sourceOptions() {
        return this._sourceOptions;
      }
      addClickHandler(t) {
        if (!_o(this)) return;
        const e = this.interactivity.element;
        if (!e) return;
        const i = (e, i, s) => {
          if (!_o(this)) return;
          const o = this.retina.pixelRatio,
            n = { x: i.x * o, y: i.y * o },
            a = this.particles.quadTree.queryCircle(n, s * o);
          t(e, a);
        };
        let s = !1,
          o = !1;
        this._clickHandlers.set("click", (t) => {
          if (!_o(this)) return;
          const e = t,
            s = { x: e.offsetX || e.clientX, y: e.offsetY || e.clientY };
          i(t, s, K);
        }),
          this._clickHandlers.set("touchstart", () => {
            _o(this) && ((s = !0), (o = !1));
          }),
          this._clickHandlers.set("touchmove", () => {
            _o(this) && (o = !0);
          }),
          this._clickHandlers.set("touchend", (t) => {
            if (_o(this)) {
              if (s && !o) {
                const e = t;
                let s = e.touches[e.touches.length - tt];
                if (
                  !s &&
                  ((s = e.changedTouches[e.changedTouches.length - tt]), !s)
                )
                  return;
                const o = this.canvas.element,
                  n = o ? o.getBoundingClientRect() : void 0,
                  a = {
                    x: s.clientX - (n ? n.left : et),
                    y: s.clientY - (n ? n.top : et),
                  };
                i(t, a, Math.max(s.radiusX, s.radiusY));
              }
              (s = !1), (o = !1);
            }
          }),
          this._clickHandlers.set("touchcancel", () => {
            _o(this) && ((s = !1), (o = !1));
          });
        for (const [t, i] of this._clickHandlers) e.addEventListener(t, i);
      }
      addLifeTime(t) {
        this._lifeTime += t;
      }
      addPath(t, e, i = !1) {
        return (
          !(!_o(this) || (!i && this.pathGenerators.has(t))) &&
          (this.pathGenerators.set(t, e), !0)
        );
      }
      alive() {
        return !this._duration || this._lifeTime <= this._duration;
      }
      clearClickHandlers() {
        if (_o(this)) {
          for (const [t, e] of this._clickHandlers)
            this.interactivity.element?.removeEventListener(t, e);
          this._clickHandlers.clear();
        }
      }
      destroy(t = !0) {
        if (_o(this)) {
          this.stop(),
            this.clearClickHandlers(),
            this.particles.destroy(),
            this.canvas.destroy();
          for (const t of this.effectDrawers.values()) t.destroy?.(this);
          for (const t of this.shapeDrawers.values()) t.destroy?.(this);
          for (const t of this.effectDrawers.keys())
            this.effectDrawers.delete(t);
          for (const t of this.shapeDrawers.keys()) this.shapeDrawers.delete(t);
          if ((this._engine.clearPlugins(this), (this.destroyed = !0), t)) {
            const t = this._engine.items,
              e = t.findIndex((t) => t === this);
            e >= st && t.splice(e, it);
          }
          this._engine.dispatchEvent(pi.containerDestroyed, {
            container: this,
          });
        }
      }
      draw(t) {
        if (!_o(this)) return;
        let e = t;
        const i = (t) => {
          e && ((this._lastFrameTime = void 0), (e = !1)), this._nextFrame(t);
        };
        this._drawAnimationFrame = oe((t) => i(t));
      }
      async export(t, e = {}) {
        for (const i of this.plugins.values()) {
          if (!i.export) continue;
          const s = await i.export(t, e);
          if (s.supported) return s.blob;
        }
        Te().error(`${f} - Export plugin with type ${t} not found`);
      }
      handleClickMode(t) {
        if (_o(this)) {
          this.particles.handleClickMode(t);
          for (const e of this.plugins.values()) e.handleClickMode?.(t);
        }
      }
      async init() {
        if (!_o(this)) return;
        const t = this._engine.getSupportedEffects();
        for (const e of t) {
          const t = this._engine.getEffectDrawer(e);
          t && this.effectDrawers.set(e, t);
        }
        const e = this._engine.getSupportedShapes();
        for (const t of e) {
          const e = this._engine.getShapeDrawer(t);
          e && this.shapeDrawers.set(t, e);
        }
        await this.particles.initPlugins(),
          (this._options = bo(
            this._engine,
            this,
            this._initialSourceOptions,
            this.sourceOptions
          )),
          (this.actualOptions = bo(this._engine, this, this._options));
        const i = await this._engine.getAvailablePlugins(this);
        for (const [t, e] of i) this.plugins.set(t, e);
        this.retina.init(),
          await this.canvas.init(),
          this.updateActualOptions(),
          this.canvas.initBackground(),
          this.canvas.resize();
        const {
          zLayers: s,
          duration: o,
          delay: n,
          fpsLimit: a,
          smooth: r,
        } = this.actualOptions;
        (this.zLayers = s),
          (this._duration = le(o) * y),
          (this._delay = le(n) * y),
          (this._lifeTime = 0),
          (this.fpsLimit = a > nt ? a : ot),
          (this._smooth = r);
        for (const t of this.effectDrawers.values()) await t.init?.(this);
        for (const t of this.shapeDrawers.values()) await t.init?.(this);
        for (const t of this.plugins.values()) await t.init?.();
        this._engine.dispatchEvent(pi.containerInit, { container: this }),
          await this.particles.init(),
          this.particles.setDensity();
        for (const t of this.plugins.values()) t.particlesSetup?.();
        this._engine.dispatchEvent(pi.particlesSetup, { container: this });
      }
      async loadTheme(t) {
        _o(this) && ((this._currentTheme = t), await this.refresh());
      }
      pause() {
        if (
          _o(this) &&
          (void 0 !== this._drawAnimationFrame &&
            (ne(this._drawAnimationFrame), delete this._drawAnimationFrame),
          !this._paused)
        ) {
          for (const t of this.plugins.values()) t.pause?.();
          this.pageHidden || (this._paused = !0),
            this._engine.dispatchEvent(pi.containerPaused, { container: this });
        }
      }
      play(t) {
        if (!_o(this)) return;
        const e = this._paused || t;
        if (!this._firstStart || this.actualOptions.autoPlay) {
          if ((this._paused && (this._paused = !1), e))
            for (const t of this.plugins.values()) t.play && t.play();
          this._engine.dispatchEvent(pi.containerPlay, { container: this }),
            this.draw(e ?? !1);
        } else this._firstStart = !1;
      }
      async refresh() {
        if (_o(this)) return this.stop(), this.start();
      }
      async reset(t) {
        if (_o(this))
          return (
            (this._initialSourceOptions = t),
            (this._sourceOptions = t),
            (this._options = bo(
              this._engine,
              this,
              this._initialSourceOptions,
              this.sourceOptions
            )),
            (this.actualOptions = bo(this._engine, this, this._options)),
            this.refresh()
          );
      }
      async start() {
        _o(this) &&
          !this.started &&
          (await this.init(),
          (this.started = !0),
          await new Promise((t) => {
            const e = async () => {
              this._eventListeners.addListeners(),
                this.interactivity.element instanceof HTMLElement &&
                  this._intersectionObserver &&
                  this._intersectionObserver.observe(
                    this.interactivity.element
                  );
              for (const t of this.plugins.values()) await t.start?.();
              this._engine.dispatchEvent(pi.containerStarted, {
                container: this,
              }),
                this.play(),
                t();
            };
            this._delayTimeout = setTimeout(() => {
              e();
            }, this._delay);
          }));
      }
      stop() {
        if (_o(this) && this.started) {
          this._delayTimeout &&
            (clearTimeout(this._delayTimeout), delete this._delayTimeout),
            (this._firstStart = !0),
            (this.started = !1),
            this._eventListeners.removeListeners(),
            this.pause(),
            this.particles.clear(),
            this.canvas.stop(),
            this.interactivity.element instanceof HTMLElement &&
              this._intersectionObserver &&
              this._intersectionObserver.unobserve(this.interactivity.element);
          for (const t of this.plugins.values()) t.stop?.();
          for (const t of this.plugins.keys()) this.plugins.delete(t);
          (this._sourceOptions = this._options),
            this._engine.dispatchEvent(pi.containerStopped, {
              container: this,
            });
        }
      }
      updateActualOptions() {
        this.actualOptions.responsive = [];
        const t = this.actualOptions.setResponsive(
          this.canvas.size.width,
          this.retina.pixelRatio,
          this._options
        );
        return (
          this.actualOptions.setTheme(this._currentTheme),
          this._responsiveMaxWidth !== t && ((this._responsiveMaxWidth = t), !0)
        );
      }
    }
    class zo {
      constructor() {
        this._listeners = new Map();
      }
      addEventListener(t, e) {
        this.removeEventListener(t, e);
        let i = this._listeners.get(t);
        i || ((i = []), this._listeners.set(t, i)), i.push(e);
      }
      dispatchEvent(t, e) {
        const i = this._listeners.get(t);
        i?.forEach((t) => t(e));
      }
      hasEventListener(t) {
        return !!this._listeners.get(t);
      }
      removeAllEventListeners(t) {
        t ? this._listeners.delete(t) : (this._listeners = new Map());
      }
      removeEventListener(t, e) {
        const i = this._listeners.get(t);
        if (!i) return;
        const s = i.length,
          o = i.indexOf(e);
        o < xt || (s === Ct ? this._listeners.delete(t) : i.splice(o, Ct));
      }
    }
    async function Mo(t, e, i, s = !1) {
      let o = e.get(t);
      return (
        (o && !s) ||
          ((o = await Promise.all([...i.values()].map((e) => e(t)))),
          e.set(t, o)),
        o
      );
    }
    class Po {
      constructor() {
        (this._configs = new Map()),
          (this._domArray = []),
          (this._eventDispatcher = new zo()),
          (this._initialized = !1),
          (this.plugins = []),
          (this.colorManagers = new Map()),
          (this.easingFunctions = new Map()),
          (this._initializers = {
            interactors: new Map(),
            movers: new Map(),
            updaters: new Map(),
          }),
          (this.interactors = new Map()),
          (this.movers = new Map()),
          (this.updaters = new Map()),
          (this.presets = new Map()),
          (this.effectDrawers = new Map()),
          (this.shapeDrawers = new Map()),
          (this.pathGenerators = new Map());
      }
      get configs() {
        const t = {};
        for (const [e, i] of this._configs) t[e] = i;
        return t;
      }
      get items() {
        return this._domArray;
      }
      get version() {
        return "3.8.1";
      }
      async addColorManager(t, e = !0) {
        this.colorManagers.set(t.key, t), await this.refresh(e);
      }
      addConfig(t) {
        const e = t.key ?? t.name ?? "default";
        this._configs.set(e, t),
          this._eventDispatcher.dispatchEvent(pi.configAdded, {
            data: { name: e, config: t },
          });
      }
      async addEasing(t, e, i = !0) {
        this.getEasing(t) ||
          (this.easingFunctions.set(t, e), await this.refresh(i));
      }
      async addEffect(t, e, i = !0) {
        ei(t, (t) => {
          this.getEffectDrawer(t) || this.effectDrawers.set(t, e);
        }),
          await this.refresh(i);
      }
      addEventListener(t, e) {
        this._eventDispatcher.addEventListener(t, e);
      }
      async addInteractor(t, e, i = !0) {
        this._initializers.interactors.set(t, e), await this.refresh(i);
      }
      async addMover(t, e, i = !0) {
        this._initializers.movers.set(t, e), await this.refresh(i);
      }
      async addParticleUpdater(t, e, i = !0) {
        this._initializers.updaters.set(t, e), await this.refresh(i);
      }
      async addPathGenerator(t, e, i = !0) {
        this.getPathGenerator(t) || this.pathGenerators.set(t, e),
          await this.refresh(i);
      }
      async addPlugin(t, e = !0) {
        this.getPlugin(t.id) || this.plugins.push(t), await this.refresh(e);
      }
      async addPreset(t, e, i = !1, s = !0) {
        (!i && this.getPreset(t)) || this.presets.set(t, e),
          await this.refresh(s);
      }
      async addShape(t, e = !0) {
        for (const e of t.validTypes)
          this.getShapeDrawer(e) || this.shapeDrawers.set(e, t);
        await this.refresh(e);
      }
      checkVersion(t) {
        if (this.version !== t)
          throw new Error(
            `The tsParticles version is different from the loaded plugins version. Engine version: ${this.version}. Plugin version: ${t}`
          );
      }
      clearPlugins(t) {
        this.updaters.delete(t),
          this.movers.delete(t),
          this.interactors.delete(t);
      }
      dispatchEvent(t, e) {
        this._eventDispatcher.dispatchEvent(t, e);
      }
      dom() {
        return this.items;
      }
      domItem(t) {
        return this.item(t);
      }
      async getAvailablePlugins(t) {
        const e = new Map();
        for (const i of this.plugins)
          i.needsPlugin(t.actualOptions) && e.set(i.id, await i.getPlugin(t));
        return e;
      }
      getEasing(t) {
        return this.easingFunctions.get(t) ?? ((t) => t);
      }
      getEffectDrawer(t) {
        return this.effectDrawers.get(t);
      }
      async getInteractors(t, e = !1) {
        return Mo(t, this.interactors, this._initializers.interactors, e);
      }
      async getMovers(t, e = !1) {
        return Mo(t, this.movers, this._initializers.movers, e);
      }
      getPathGenerator(t) {
        return this.pathGenerators.get(t);
      }
      getPlugin(t) {
        return this.plugins.find((e) => e.id === t);
      }
      getPreset(t) {
        return this.presets.get(t);
      }
      getShapeDrawer(t) {
        return this.shapeDrawers.get(t);
      }
      getSupportedEffects() {
        return this.effectDrawers.keys();
      }
      getSupportedShapes() {
        return this.shapeDrawers.keys();
      }
      async getUpdaters(t, e = !1) {
        return Mo(t, this.updaters, this._initializers.updaters, e);
      }
      init() {
        this._initialized || (this._initialized = !0);
      }
      item(t) {
        const { items: e } = this,
          i = e[t];
        if (i && !i.destroyed) return i;
        e.splice(t, it);
      }
      async load(t) {
        const e =
            t.id ?? t.element?.id ?? `tsparticles${Math.floor(ie() * rt)}`,
          { index: s, url: o } = t,
          n = o
            ? await (async function (t) {
                const e = ii(t.url, t.index);
                if (!e) return t.fallback;
                const i = await fetch(e);
                return i.ok
                  ? await i.json()
                  : (Te().error(
                      `${f} ${i.status} while retrieving config file`
                    ),
                    t.fallback);
              })({ fallback: t.options, url: o, index: s })
            : t.options,
          a = ii(n, s),
          { items: r } = this,
          c = r.findIndex((t) => t.id.description === e),
          l = new xo(this, e, a);
        if (c >= ct) {
          const t = this.item(c),
            e = t ? lt : ht;
          t && !t.destroyed && t.destroy(!1), r.splice(c, e, l);
        } else r.push(l);
        const h = ((t, e) => {
            let s = e ?? document.getElementById(t);
            return (
              s ||
              ((s = document.createElement("div")),
              (s.id = t),
              (s.dataset[i] = C),
              document.body.append(s),
              s)
            );
          })(e, t.element),
          d = ((t) => {
            let e;
            if (t instanceof HTMLCanvasElement || t.tagName.toLowerCase() === k)
              (e = t), e.dataset[i] || (e.dataset[i] = O);
            else {
              const s = t.getElementsByTagName(k);
              s.length
                ? ((e = s[at]), (e.dataset[i] = O))
                : ((e = document.createElement(k)),
                  (e.dataset[i] = C),
                  t.appendChild(e));
            }
            const s = "100%";
            return (
              e.style.width || (e.style.width = s),
              e.style.height || (e.style.height = s),
              e
            );
          })(h);
        return l.canvas.loadCanvas(d), await l.start(), l;
      }
      loadOptions(t, e) {
        this.plugins.forEach((i) => i.loadOptions?.(t, e));
      }
      loadParticlesOptions(t, e, ...i) {
        const s = this.updaters.get(t);
        s && s.forEach((t) => t.loadOptions?.(e, ...i));
      }
      async refresh(t = !0) {
        t && (await Promise.all(this.items.map((t) => t.refresh())));
      }
      removeEventListener(t, e) {
        this._eventDispatcher.removeEventListener(t, e);
      }
      setOnClickHandler(t) {
        const { items: e } = this;
        if (!e.length)
          throw new Error(
            `${f} can only set click handlers after calling tsParticles.load()`
          );
        e.forEach((e) => e.addClickHandler(t));
      }
    }
    class Co {
      constructor(t) {
        (this.type = _i.external), (this.container = t);
      }
    }
    class Oo {
      constructor(t) {
        (this.type = _i.particles), (this.container = t);
      }
    }
    var ko, So, Do;
    !(function (t) {
      (t.clockwise = "clockwise"),
        (t.counterClockwise = "counter-clockwise"),
        (t.random = "random");
    })(ko || (ko = {})),
      (function (t) {
        (t.linear = "linear"), (t.radial = "radial"), (t.random = "random");
      })(So || (So = {})),
      (function (t) {
        (t.easeInBack = "ease-in-back"),
          (t.easeInCirc = "ease-in-circ"),
          (t.easeInCubic = "ease-in-cubic"),
          (t.easeInLinear = "ease-in-linear"),
          (t.easeInQuad = "ease-in-quad"),
          (t.easeInQuart = "ease-in-quart"),
          (t.easeInQuint = "ease-in-quint"),
          (t.easeInExpo = "ease-in-expo"),
          (t.easeInSine = "ease-in-sine"),
          (t.easeOutBack = "ease-out-back"),
          (t.easeOutCirc = "ease-out-circ"),
          (t.easeOutCubic = "ease-out-cubic"),
          (t.easeOutLinear = "ease-out-linear"),
          (t.easeOutQuad = "ease-out-quad"),
          (t.easeOutQuart = "ease-out-quart"),
          (t.easeOutQuint = "ease-out-quint"),
          (t.easeOutExpo = "ease-out-expo"),
          (t.easeOutSine = "ease-out-sine"),
          (t.easeInOutBack = "ease-in-out-back"),
          (t.easeInOutCirc = "ease-in-out-circ"),
          (t.easeInOutCubic = "ease-in-out-cubic"),
          (t.easeInOutLinear = "ease-in-out-linear"),
          (t.easeInOutQuad = "ease-in-out-quad"),
          (t.easeInOutQuart = "ease-in-out-quart"),
          (t.easeInOutQuint = "ease-in-out-quint"),
          (t.easeInOutExpo = "ease-in-out-expo"),
          (t.easeInOutSine = "ease-in-out-sine");
      })(Do || (Do = {}));
    const Ro = (function () {
      const t = new Po();
      return t.init(), t;
    })();
    Le() || (window.tsParticles = Ro);
    class Eo {
      constructor() {
        (this.background = "none"),
          (this.brightness = { min: -30, max: 30 }),
          (this.colors = [
            "#ff595e",
            "#ffca3a",
            "#8ac926",
            "#1982c4",
            "#6a4c93",
          ]),
          (this.gravity = 5),
          (this.minHeight = { min: 10, max: 30 }),
          (this.rate = 10),
          (this.saturation = { min: -30, max: 30 }),
          (this.sounds = !0),
          (this.speed = { min: 5, max: 15 }),
          (this.splitCount = { min: 75, max: 150 });
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.background && (this.background = t.background),
          void 0 !== t.colors &&
            (Xt(t.colors)
              ? (this.colors = [...t.colors])
              : (this.colors = t.colors)),
          void 0 !== t.brightness && (this.brightness = ue(t.brightness)),
          void 0 !== t.gravity && (this.gravity = ue(t.gravity)),
          void 0 !== t.minHeight && (this.minHeight = ue(t.minHeight)),
          void 0 !== t.rate && (this.rate = ue(t.rate)),
          void 0 !== t.saturation && (this.saturation = ue(t.saturation)),
          void 0 !== t.sounds && (this.sounds = t.sounds),
          void 0 !== t.speed && (this.speed = ue(t.speed)),
          void 0 !== t.splitCount && (this.splitCount = ue(t.splitCount)));
      }
    }
    const To = 1,
      Io = 2 * Math.PI;
    function Lo(t, e, i, s, o, n) {
      !(function (t, e) {
        const i = t.options,
          s = i.move.path;
        if (!s.enable) return;
        if (t.lastPathTime <= t.pathDelay)
          return void (t.lastPathTime += e.value);
        const o = t.pathGenerator?.generate(t, e);
        o && t.velocity.addTo(o);
        s.clamp &&
          ((t.velocity.x = ae(t.velocity.x, -To, To)),
          (t.velocity.y = ae(t.velocity.y, -To, To)));
        t.lastPathTime -= t.pathDelay;
      })(t, n);
      const a = t.gravity,
        r = a?.enable && a.inverse ? -To : To;
      o && i && (t.velocity.x += (o * n.factor) / (60 * i)),
        a?.enable &&
          i &&
          (t.velocity.y += (r * (a.acceleration * n.factor)) / (60 * i));
      const c = t.moveDecay;
      t.velocity.multTo(c);
      const l = t.velocity.mult(i);
      a?.enable &&
        s > 0 &&
        ((!a.inverse && l.y >= 0 && l.y >= s) ||
          (a.inverse && l.y <= 0 && l.y <= -s)) &&
        ((l.y = r * s), i && (t.velocity.y = l.y / i));
      const h = t.options.zIndex,
        d = (To - t.zIndexFactor) ** h.velocityRate;
      l.multTo(d);
      const { position: u } = t;
      u.addTo(l),
        e.vibrate &&
          ((u.x += Math.sin(u.x * Math.cos(u.y))),
          (u.y += Math.cos(u.y * Math.sin(u.x))));
    }
    class Fo {
      init(t) {
        const e = t.options.move.gravity;
        (t.gravity = {
          enable: e.enable,
          acceleration: le(e.acceleration),
          inverse: e.inverse,
        }),
          (function (t) {
            const e = t.container,
              i = t.options.move.spin;
            if (!i.enable) return;
            const s = i.position ?? { x: 50, y: 50 },
              o = {
                x: 0.01 * s.x * e.canvas.size.width,
                y: 0.01 * s.y * e.canvas.size.height,
              },
              n = fe(t.getPosition(), o),
              a = le(i.acceleration);
            (t.retina.spinAcceleration = a * e.retina.pixelRatio),
              (t.spin = {
                center: o,
                direction:
                  t.velocity.x >= 0 ? ko.clockwise : ko.counterClockwise,
                angle: ie() * Io,
                radius: n,
                acceleration: t.retina.spinAcceleration,
              });
          })(t);
      }
      isEnabled(t) {
        return !t.destroyed && t.options.move.enable;
      }
      move(t, e) {
        const i = t.options,
          s = i.move;
        if (!s.enable) return;
        const o = t.container,
          n = o.retina.pixelRatio;
        (t.retina.moveSpeed ??= le(s.speed) * n),
          (t.retina.moveDrift ??= le(t.options.move.drift) * n);
        const a = (function (t) {
            return t.slow.inRange ? t.slow.factor : To;
          })(t),
          r = t.retina.moveSpeed * o.retina.reduceFactor,
          c = t.retina.moveDrift,
          l = de(i.size.value) * n,
          h = (r * (s.size ? t.getRadius() / l : 1) * a * (e.factor || 1)) / 2,
          d = t.retina.maxSpeed ?? o.retina.maxSpeed;
        s.spin.enable
          ? (function (t, e) {
              const i = t.container;
              if (!t.spin) return;
              const s = t.spin.direction === ko.clockwise,
                o = { x: s ? Math.cos : Math.sin, y: s ? Math.sin : Math.cos };
              (t.position.x =
                t.spin.center.x + t.spin.radius * o.x(t.spin.angle)),
                (t.position.y =
                  t.spin.center.y + t.spin.radius * o.y(t.spin.angle)),
                (t.spin.radius += t.spin.acceleration);
              const n = Math.max(i.canvas.size.width, i.canvas.size.height),
                a = 0.5 * n;
              t.spin.radius > a
                ? ((t.spin.radius = a), (t.spin.acceleration *= -To))
                : t.spin.radius < 0 &&
                  ((t.spin.radius = 0), (t.spin.acceleration *= -To)),
                (t.spin.angle += 0.01 * e * (To - t.spin.radius / n));
            })(t, h)
          : Lo(t, s, h, d, c, e),
          (function (t) {
            const e = t.initialPosition,
              { dx: i, dy: s } = pe(e, t.position),
              o = Math.abs(i),
              n = Math.abs(s),
              { maxDistance: a } = t.retina,
              r = a.horizontal,
              c = a.vertical;
            if (!r && !c) return;
            if (((r && o >= r) || (c && n >= c)) && !t.misplaced)
              (t.misplaced = (!!r && o > r) || (!!c && n > c)),
                r && (t.velocity.x = 0.5 * t.velocity.y - t.velocity.x),
                c && (t.velocity.y = 0.5 * t.velocity.x - t.velocity.y);
            else if ((!r || o < r) && (!c || n < c) && t.misplaced)
              t.misplaced = !1;
            else if (t.misplaced) {
              const i = t.position,
                s = t.velocity;
              r &&
                ((i.x < e.x && s.x < 0) || (i.x > e.x && s.x > 0)) &&
                (s.x *= -ie()),
                c &&
                  ((i.y < e.y && s.y < 0) || (i.y > e.y && s.y > 0)) &&
                  (s.y *= -ie());
            }
          })(t);
      }
    }
    const Ao = 2 * Math.PI,
      Vo = 0,
      Bo = 0;
    class Uo {
      constructor() {
        this.validTypes = ["circle"];
      }
      draw(t) {
        !(function (t) {
          const { context: e, particle: i, radius: s } = t;
          i.circleRange || (i.circleRange = { min: 0, max: Ao });
          const o = i.circleRange;
          e.arc(Vo, Bo, s, o.min, o.max, !1);
        })(t);
      }
      getSidesCount() {
        return 12;
      }
      particleInit(t, e) {
        const i = e.shapeData,
          s = i?.angle ?? { max: 360, min: 0 };
        e.circleRange = Qt(s)
          ? { min: me(s.min), max: me(s.max) }
          : { min: 0, max: me(s) };
      }
    }
    class Wo {
      constructor(t, e) {
        (this._container = t), (this._engine = e);
      }
      init(t) {
        const e = Oi(
          this._engine,
          t.options.color,
          t.id,
          t.options.reduceDuplicates
        );
        e &&
          (t.color = Ui(
            e,
            t.options.color.animation,
            this._container.retina.reduceFactor
          ));
      }
      isEnabled(t) {
        const { h: e, s: i, l: s } = t.options.color.animation,
          { color: o } = t;
        return (
          !t.destroyed &&
          !t.spawning &&
          ((void 0 !== o?.h.value && e.enable) ||
            (void 0 !== o?.s.value && i.enable) ||
            (void 0 !== o?.l.value && s.enable))
        );
      }
      update(t, e) {
        qi(t.color, e);
      }
    }
    var Ho;
    !(function (t) {
      (t[(t.r = 1)] = "r"),
        (t[(t.g = 2)] = "g"),
        (t[(t.b = 3)] = "b"),
        (t[(t.a = 4)] = "a");
    })(Ho || (Ho = {}));
    const qo = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i,
      Go = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
    class No {
      constructor() {
        (this.key = "hex"), (this.stringPrefix = "#");
      }
      handleColor(t) {
        return this._parseString(t.value);
      }
      handleRangeColor(t) {
        return this._parseString(t.value);
      }
      parseString(t) {
        return this._parseString(t);
      }
      _parseString(t) {
        if ("string" != typeof t) return;
        if (!t?.startsWith(this.stringPrefix)) return;
        const e = t.replace(
            qo,
            (t, e, i, s, o) =>
              e + e + i + i + s + s + (void 0 !== o ? o + o : "")
          ),
          i = Go.exec(e);
        return i
          ? {
              a: void 0 !== i[Ho.a] ? parseInt(i[Ho.a], 16) / 255 : 1,
              b: parseInt(i[Ho.b], 16),
              g: parseInt(i[Ho.g], 16),
              r: parseInt(i[Ho.r], 16),
            }
          : void 0;
      }
    }
    var $o;
    !(function (t) {
      (t[(t.h = 1)] = "h"),
        (t[(t.s = 2)] = "s"),
        (t[(t.l = 3)] = "l"),
        (t[(t.a = 5)] = "a");
    })($o || ($o = {}));
    class jo {
      constructor() {
        (this.key = "hsl"), (this.stringPrefix = "hsl");
      }
      handleColor(t) {
        const e = t.value.hsl ?? t.value;
        if (void 0 !== e.h && void 0 !== e.s && void 0 !== e.l) return Ri(e);
      }
      handleRangeColor(t) {
        const e = t.value.hsl ?? t.value;
        if (void 0 !== e.h && void 0 !== e.l)
          return Ri({ h: le(e.h), l: le(e.l), s: le(e.s) });
      }
      parseString(t) {
        if (!t.startsWith("hsl")) return;
        const e =
          /hsla?\(\s*(\d+)\s*[\s,]\s*(\d+)%\s*[\s,]\s*(\d+)%\s*([\s,]\s*(0|1|0?\.\d+|(\d{1,3})%)\s*)?\)/i.exec(
            t
          );
        return e
          ? Ei({
              a: e.length > 4 ? Me(e[$o.a]) : 1,
              h: parseInt(e[$o.h], 10),
              l: parseInt(e[$o.l], 10),
              s: parseInt(e[$o.s], 10),
            })
          : void 0;
      }
    }
    class Qo {
      constructor(t) {
        this.container = t;
      }
      init(t) {
        const e = t.options.opacity;
        t.opacity = oi(e, 1);
        const i = e.animation;
        i.enable &&
          ((t.opacity.velocity =
            (le(i.speed) / m) * this.container.retina.reduceFactor),
          i.sync || (t.opacity.velocity *= ie()));
      }
      isEnabled(t) {
        return (
          !t.destroyed &&
          !t.spawning &&
          !!t.opacity &&
          t.opacity.enable &&
          ((t.opacity.maxLoops ?? 0) <= 0 ||
            ((t.opacity.maxLoops ?? 0) > 0 &&
              (t.opacity.loops ?? 0) < (t.opacity.maxLoops ?? 0)))
        );
      }
      reset(t) {
        t.opacity && ((t.opacity.time = 0), (t.opacity.loops = 0));
      }
      update(t, e) {
        this.isEnabled(t) &&
          t.opacity &&
          ci(t, t.opacity, !0, t.options.opacity.animation.destroy, e);
      }
    }
    class Xo {
      constructor(t) {
        (this.container = t), (this.modes = [gi.bounce, gi.split]);
      }
      update(t, e, i, s) {
        if (!this.modes.includes(s)) return;
        const o = this.container;
        let n = !1;
        for (const s of o.plugins.values())
          if (
            (void 0 !== s.particleBounce && (n = s.particleBounce(t, i, e)), n)
          )
            break;
        if (n) return;
        const a = t.getPosition(),
          r = t.offset,
          c = t.getRadius(),
          l = $e(a, c),
          h = o.canvas.size;
        !(function (t) {
          if (
            (t.outMode !== gi.bounce && t.outMode !== gi.split) ||
            (t.direction !== ke.left && t.direction !== ke.right)
          )
            return;
          t.bounds.right < 0 && t.direction === ke.left
            ? (t.particle.position.x = t.size + t.offset.x)
            : t.bounds.left > t.canvasSize.width &&
              t.direction === ke.right &&
              (t.particle.position.x =
                t.canvasSize.width - t.size - t.offset.x);
          const e = t.particle.velocity.x;
          let i = !1;
          if (
            (t.direction === ke.right &&
              t.bounds.right >= t.canvasSize.width &&
              e > 0) ||
            (t.direction === ke.left && t.bounds.left <= 0 && e < 0)
          ) {
            const e = le(t.particle.options.bounce.horizontal.value);
            (t.particle.velocity.x *= -e), (i = !0);
          }
          if (!i) return;
          const s = t.offset.x + t.size;
          t.bounds.right >= t.canvasSize.width && t.direction === ke.right
            ? (t.particle.position.x = t.canvasSize.width - s)
            : t.bounds.left <= 0 &&
              t.direction === ke.left &&
              (t.particle.position.x = s),
            t.outMode === gi.split && t.particle.destroy();
        })({
          particle: t,
          outMode: s,
          direction: e,
          bounds: l,
          canvasSize: h,
          offset: r,
          size: c,
        }),
          (function (t) {
            if (
              (t.outMode !== gi.bounce && t.outMode !== gi.split) ||
              (t.direction !== ke.bottom && t.direction !== ke.top)
            )
              return;
            t.bounds.bottom < 0 && t.direction === ke.top
              ? (t.particle.position.y = t.size + t.offset.y)
              : t.bounds.top > t.canvasSize.height &&
                t.direction === ke.bottom &&
                (t.particle.position.y =
                  t.canvasSize.height - t.size - t.offset.y);
            const e = t.particle.velocity.y;
            let i = !1;
            if (
              (t.direction === ke.bottom &&
                t.bounds.bottom >= t.canvasSize.height &&
                e > 0) ||
              (t.direction === ke.top && t.bounds.top <= 0 && e < 0)
            ) {
              const e = le(t.particle.options.bounce.vertical.value);
              (t.particle.velocity.y *= -e), (i = !0);
            }
            if (!i) return;
            const s = t.offset.y + t.size;
            t.bounds.bottom >= t.canvasSize.height && t.direction === ke.bottom
              ? (t.particle.position.y = t.canvasSize.height - s)
              : t.bounds.top <= 0 &&
                t.direction === ke.top &&
                (t.particle.position.y = s),
              t.outMode === gi.split && t.particle.destroy();
          })({
            particle: t,
            outMode: s,
            direction: e,
            bounds: l,
            canvasSize: h,
            offset: r,
            size: c,
          });
      }
    }
    class Yo {
      constructor(t) {
        (this.container = t), (this.modes = [gi.destroy]);
      }
      update(t, e, i, s) {
        if (!this.modes.includes(s)) return;
        const o = this.container;
        switch (t.outType) {
          case bi.normal:
          case bi.outside:
            if (Ge(t.position, o.canvas.size, Jt.origin, t.getRadius(), e))
              return;
            break;
          case bi.inside: {
            const { dx: e, dy: i } = pe(t.position, t.moveCenter),
              { x: s, y: o } = t.velocity;
            if (
              (s < 0 && e > t.moveCenter.radius) ||
              (o < 0 && i > t.moveCenter.radius) ||
              (s >= 0 && e < -t.moveCenter.radius) ||
              (o >= 0 && i < -t.moveCenter.radius)
            )
              return;
            break;
          }
        }
        o.particles.remove(t, t.group, !0);
      }
    }
    class Zo {
      constructor(t) {
        (this.container = t), (this.modes = [gi.none]);
      }
      update(t, e, i, s) {
        if (!this.modes.includes(s)) return;
        if (
          (t.options.move.distance.horizontal &&
            (e === ke.left || e === ke.right)) ??
          (t.options.move.distance.vertical &&
            (e === ke.top || e === ke.bottom))
        )
          return;
        const o = t.options.move.gravity,
          n = this.container,
          a = n.canvas.size,
          r = t.getRadius();
        if (o.enable) {
          const i = t.position;
          ((!o.inverse && i.y > a.height + r && e === ke.bottom) ||
            (o.inverse && i.y < -r && e === ke.top)) &&
            n.particles.remove(t);
        } else {
          if (
            (t.velocity.y > 0 && t.position.y <= a.height + r) ||
            (t.velocity.y < 0 && t.position.y >= -r) ||
            (t.velocity.x > 0 && t.position.x <= a.width + r) ||
            (t.velocity.x < 0 && t.position.x >= -r)
          )
            return;
          Ge(t.position, n.canvas.size, Jt.origin, r, e) ||
            n.particles.remove(t);
        }
      }
    }
    class Jo {
      constructor(t) {
        (this.container = t), (this.modes = [gi.out]);
      }
      update(t, e, i, s) {
        if (!this.modes.includes(s)) return;
        const o = this.container;
        switch (t.outType) {
          case bi.inside: {
            const { x: e, y: i } = t.velocity,
              s = Jt.origin;
            (s.length = t.moveCenter.radius),
              (s.angle = t.velocity.angle + Math.PI),
              s.addTo(Jt.create(t.moveCenter));
            const { dx: n, dy: a } = pe(t.position, s);
            if (
              (e <= 0 && n >= 0) ||
              (i <= 0 && a >= 0) ||
              (e >= 0 && n <= 0) ||
              (i >= 0 && a <= 0)
            )
              return;
            (t.position.x = Math.floor(
              ce({ min: 0, max: o.canvas.size.width })
            )),
              (t.position.y = Math.floor(
                ce({ min: 0, max: o.canvas.size.height })
              ));
            const { dx: r, dy: c } = pe(t.position, t.moveCenter);
            (t.direction = Math.atan2(-c, -r)),
              (t.velocity.angle = t.direction);
            break;
          }
          default:
            if (Ge(t.position, o.canvas.size, Jt.origin, t.getRadius(), e))
              return;
            switch (t.outType) {
              case bi.outside: {
                (t.position.x =
                  Math.floor(
                    ce({ min: -t.moveCenter.radius, max: t.moveCenter.radius })
                  ) + t.moveCenter.x),
                  (t.position.y =
                    Math.floor(
                      ce({
                        min: -t.moveCenter.radius,
                        max: t.moveCenter.radius,
                      })
                    ) + t.moveCenter.y);
                const { dx: e, dy: i } = pe(t.position, t.moveCenter);
                t.moveCenter.radius &&
                  ((t.direction = Math.atan2(i, e)),
                  (t.velocity.angle = t.direction));
                break;
              }
              case bi.normal: {
                const i = t.options.move.warp,
                  s = o.canvas.size,
                  n = {
                    bottom: s.height + t.getRadius() + t.offset.y,
                    left: -t.getRadius() - t.offset.x,
                    right: s.width + t.getRadius() + t.offset.x,
                    top: -t.getRadius() - t.offset.y,
                  },
                  a = t.getRadius(),
                  r = $e(t.position, a);
                e === ke.right && r.left > s.width + t.offset.x
                  ? ((t.position.x = n.left),
                    (t.initialPosition.x = t.position.x),
                    i ||
                      ((t.position.y = ie() * s.height),
                      (t.initialPosition.y = t.position.y)))
                  : e === ke.left &&
                    r.right < -t.offset.x &&
                    ((t.position.x = n.right),
                    (t.initialPosition.x = t.position.x),
                    i ||
                      ((t.position.y = ie() * s.height),
                      (t.initialPosition.y = t.position.y))),
                  e === ke.bottom && r.top > s.height + t.offset.y
                    ? (i ||
                        ((t.position.x = ie() * s.width),
                        (t.initialPosition.x = t.position.x)),
                      (t.position.y = n.top),
                      (t.initialPosition.y = t.position.y))
                    : e === ke.top &&
                      r.bottom < -t.offset.y &&
                      (i ||
                        ((t.position.x = ie() * s.width),
                        (t.initialPosition.x = t.position.x)),
                      (t.position.y = n.bottom),
                      (t.initialPosition.y = t.position.y));
                break;
              }
            }
        }
      }
    }
    class Ko {
      constructor(t) {
        (this._addUpdaterIfMissing = (t, e, i) => {
          const s = t.options.move.outModes;
          !this.updaters.has(e) &&
            ((t, e) =>
              t.default === e ||
              t.bottom === e ||
              t.left === e ||
              t.right === e ||
              t.top === e)(s, e) &&
            this.updaters.set(e, i(this.container));
        }),
          (this._updateOutMode = (t, e, i, s) => {
            for (const o of this.updaters.values()) o.update(t, s, e, i);
          }),
          (this.container = t),
          (this.updaters = new Map());
      }
      init(t) {
        this._addUpdaterIfMissing(t, gi.bounce, (t) => new Xo(t)),
          this._addUpdaterIfMissing(t, gi.out, (t) => new Jo(t)),
          this._addUpdaterIfMissing(t, gi.destroy, (t) => new Yo(t)),
          this._addUpdaterIfMissing(t, gi.none, (t) => new Zo(t));
      }
      isEnabled(t) {
        return !t.destroyed && !t.spawning;
      }
      update(t, e) {
        const i = t.options.move.outModes;
        this._updateOutMode(t, e, i.bottom ?? i.default, ke.bottom),
          this._updateOutMode(t, e, i.left ?? i.default, ke.left),
          this._updateOutMode(t, e, i.right ?? i.default, ke.right),
          this._updateOutMode(t, e, i.top ?? i.default, ke.top);
      }
    }
    var tn;
    !(function (t) {
      (t[(t.r = 1)] = "r"),
        (t[(t.g = 2)] = "g"),
        (t[(t.b = 3)] = "b"),
        (t[(t.a = 5)] = "a");
    })(tn || (tn = {}));
    class en {
      constructor() {
        (this.key = "rgb"), (this.stringPrefix = "rgb");
      }
      handleColor(t) {
        const e = t.value.rgb ?? t.value;
        if (void 0 !== e.r) return e;
      }
      handleRangeColor(t) {
        const e = t.value.rgb ?? t.value;
        if (void 0 !== e.r) return { r: le(e.r), g: le(e.g), b: le(e.b) };
      }
      parseString(t) {
        if (!t.startsWith(this.stringPrefix)) return;
        const e =
          /rgba?\(\s*(\d{1,3})\s*[\s,]\s*(\d{1,3})\s*[\s,]\s*(\d{1,3})\s*([\s,]\s*(0|1|0?\.\d+|(\d{1,3})%)\s*)?\)/i.exec(
            t
          );
        return e
          ? {
              a: e.length > 4 ? Me(e[tn.a]) : 1,
              b: parseInt(e[tn.b], 10),
              g: parseInt(e[tn.g], 10),
              r: parseInt(e[tn.r], 10),
            }
          : void 0;
      }
    }
    class sn {
      init(t) {
        const e = t.container,
          i = t.options.size.animation;
        i.enable &&
          ((t.size.velocity =
            ((t.retina.sizeAnimationSpeed ?? e.retina.sizeAnimationSpeed) / m) *
            e.retina.reduceFactor),
          i.sync || (t.size.velocity *= ie()));
      }
      isEnabled(t) {
        return (
          !t.destroyed &&
          !t.spawning &&
          t.size.enable &&
          ((t.size.maxLoops ?? 0) <= 0 ||
            ((t.size.maxLoops ?? 0) > 0 &&
              (t.size.loops ?? 0) < (t.size.maxLoops ?? 0)))
        );
      }
      reset(t) {
        t.size.loops = 0;
      }
      update(t, e) {
        this.isEnabled(t) &&
          ci(t, t.size, !0, t.options.size.animation.destroy, e);
      }
    }
    async function on(t, e = !0) {
      t.checkVersion("3.8.1"),
        await (async function (t, e = !0) {
          t.checkVersion("3.8.1"), await t.addColorManager(new No(), e);
        })(t, !1),
        await (async function (t, e = !0) {
          t.checkVersion("3.8.1"), await t.addColorManager(new jo(), e);
        })(t, !1),
        await (async function (t, e = !0) {
          t.checkVersion("3.8.1"), await t.addColorManager(new en(), e);
        })(t, !1),
        await (async function (t, e = !0) {
          t.checkVersion("3.8.1"),
            await t.addMover("base", () => Promise.resolve(new Fo()), e);
        })(t, !1),
        await (async function (t, e = !0) {
          t.checkVersion("3.8.1"), await t.addShape(new Uo(), e);
        })(t, !1),
        await (async function (t, e = !0) {
          t.checkVersion("3.8.1"),
            await t.addParticleUpdater(
              "color",
              (e) => Promise.resolve(new Wo(e, t)),
              e
            );
        })(t, !1),
        await (async function (t, e = !0) {
          t.checkVersion("3.8.1"),
            await t.addParticleUpdater(
              "opacity",
              (t) => Promise.resolve(new Qo(t)),
              e
            );
        })(t, !1),
        await (async function (t, e = !0) {
          t.checkVersion("3.8.1"),
            await t.addParticleUpdater(
              "outModes",
              (t) => Promise.resolve(new Ko(t)),
              e
            );
        })(t, !1),
        await (async function (t, e = !0) {
          t.checkVersion("3.8.1"),
            await t.addParticleUpdater(
              "size",
              () => Promise.resolve(new sn()),
              e
            );
        })(t, !1),
        await t.refresh(e);
    }
    class nn {
      load(t) {
        Yt(t) ||
          (void 0 !== t.bottom && (this.bottom = ue(t.bottom)),
          void 0 !== t.left && (this.left = ue(t.left)),
          void 0 !== t.right && (this.right = ue(t.right)),
          void 0 !== t.top && (this.top = ue(t.top)));
      }
    }
    var an;
    !(function (t) {
      (t.none = "none"), (t.split = "split");
    })(an || (an = {}));
    class rn extends Ds {
      constructor() {
        super(), (this.value = 3);
      }
    }
    class cn extends Ds {
      constructor() {
        super(), (this.value = { min: 4, max: 9 });
      }
    }
    class ln {
      constructor() {
        (this.count = 1),
          (this.factor = new rn()),
          (this.rate = new cn()),
          (this.sizeOffset = !0);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.color && (this.color = as.create(this.color, t.color)),
          void 0 !== t.count && (this.count = t.count),
          this.factor.load(t.factor),
          this.rate.load(t.rate),
          (this.particles = ei(t.particles, (t) => je({}, t))),
          void 0 !== t.sizeOffset && (this.sizeOffset = t.sizeOffset),
          t.colorOffset &&
            ((this.colorOffset = this.colorOffset ?? {}),
            void 0 !== t.colorOffset.h &&
              (this.colorOffset.h = t.colorOffset.h),
            void 0 !== t.colorOffset.s &&
              (this.colorOffset.s = t.colorOffset.s),
            void 0 !== t.colorOffset.l &&
              (this.colorOffset.l = t.colorOffset.l)));
      }
    }
    class hn {
      constructor() {
        (this.bounds = new nn()),
          (this.mode = an.none),
          (this.split = new ln());
      }
      load(t) {
        Yt(t) ||
          (t.mode && (this.mode = t.mode),
          t.bounds && this.bounds.load(t.bounds),
          this.split.load(t.split));
      }
    }
    const dn = 0,
      un = 0.5,
      pn = 0,
      fn = 1,
      mn = 500;
    function vn(t, e, i, s) {
      const o = i.options.destroy;
      if (!o) return;
      const n = o.split,
        a = ao(t, e, i.options),
        r = le(n.factor.value),
        c = i.getFillColor();
      n.color
        ? a.color.load(n.color)
        : n.colorOffset && c
        ? a.color.load({
            value: {
              hsl: {
                h: c.h + le(n.colorOffset.h ?? dn),
                s: c.s + le(n.colorOffset.s ?? dn),
                l: c.l + le(n.colorOffset.l ?? dn),
              },
            },
          })
        : a.color.load({ value: { hsl: i.getFillColor() } }),
        a.move.load({
          center: { x: i.position.x, y: i.position.y, mode: Se.precise },
        }),
        $t(a.size.value)
          ? (a.size.value /= r)
          : ((a.size.value.min /= r), (a.size.value.max /= r)),
        a.load(s);
      const l = n.sizeOffset ? ue(-i.size.value, i.size.value) : dn,
        h = { x: i.position.x + ce(l), y: i.position.y + ce(l) };
      return e.particles.addParticle(
        h,
        a,
        i.group,
        (t) =>
          !(t.size.value < un) &&
          ((t.velocity.length = ce(ue(i.velocity.length, t.velocity.length))),
          (t.splitCount = (i.splitCount ?? pn) + fn),
          (t.unbreakable = !0),
          setTimeout(() => {
            t.unbreakable = !1;
          }, mn),
          !0)
      );
    }
    class yn {
      constructor(t, e) {
        (this.container = e), (this.engine = t);
      }
      init(t) {
        const e = this.container,
          i = t.options.destroy;
        if (!i) return;
        t.splitCount = 0;
        const s = i.bounds;
        t.destroyBounds || (t.destroyBounds = {});
        const { bottom: o, left: n, right: a, top: r } = s,
          { destroyBounds: c } = t,
          l = e.canvas.size;
        o && (c.bottom = (le(o) * l.height) / m),
          n && (c.left = (le(n) * l.width) / m),
          a && (c.right = (le(a) * l.width) / m),
          r && (c.top = (le(r) * l.height) / m);
      }
      isEnabled(t) {
        return !t.destroyed;
      }
      loadOptions(t, ...e) {
        t.destroy || (t.destroy = new hn());
        for (const i of e) t.destroy.load(i?.destroy);
      }
      particleDestroyed(t, e) {
        if (e) return;
        const i = t.options.destroy;
        i &&
          i.mode === an.split &&
          (function (t, e, i) {
            const s = i.options.destroy;
            if (!s) return;
            const o = s.split;
            if (
              o.count >= 0 &&
              (void 0 === i.splitCount || i.splitCount++ > o.count)
            )
              return;
            const n = le(o.rate.value),
              a = ii(o.particles);
            for (let s = 0; s < n; s++) vn(t, e, i, a);
          })(this.engine, this.container, t);
      }
      update(t) {
        if (!this.isEnabled(t)) return;
        const e = t.getPosition(),
          i = t.destroyBounds;
        i &&
          ((void 0 !== i.bottom && e.y >= i.bottom) ||
            (void 0 !== i.left && e.x <= i.left) ||
            (void 0 !== i.right && e.x >= i.right) ||
            (void 0 !== i.top && e.y <= i.top)) &&
          t.destroy();
      }
    }
    class gn {
      constructor() {
        this.wait = !1;
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.count && (this.count = t.count),
          void 0 !== t.delay && (this.delay = ue(t.delay)),
          void 0 !== t.duration && (this.duration = ue(t.duration)),
          void 0 !== t.wait && (this.wait = t.wait));
      }
    }
    class wn {
      constructor() {
        (this.quantity = 1), (this.delay = 0.1);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.quantity && (this.quantity = ue(t.quantity)),
          void 0 !== t.delay && (this.delay = ue(t.delay)));
      }
    }
    class _n {
      constructor() {
        (this.color = !1), (this.opacity = !1);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.color && (this.color = t.color),
          void 0 !== t.opacity && (this.opacity = t.opacity));
      }
    }
    class bn {
      constructor() {
        (this.options = {}), (this.replace = new _n()), (this.type = "square");
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.options && (this.options = je({}, t.options ?? {})),
          this.replace.load(t.replace),
          void 0 !== t.type && (this.type = t.type));
      }
    }
    class xn {
      constructor() {
        (this.mode = Se.percent), (this.height = 0), (this.width = 0);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.mode && (this.mode = t.mode),
          void 0 !== t.height && (this.height = t.height),
          void 0 !== t.width && (this.width = t.width));
      }
    }
    class zn {
      constructor() {
        (this.autoPlay = !0),
          (this.fill = !0),
          (this.life = new gn()),
          (this.rate = new wn()),
          (this.shape = new bn()),
          (this.startCount = 0);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.autoPlay && (this.autoPlay = t.autoPlay),
          void 0 !== t.size &&
            (this.size || (this.size = new xn()), this.size.load(t.size)),
          void 0 !== t.direction && (this.direction = t.direction),
          (this.domId = t.domId),
          void 0 !== t.fill && (this.fill = t.fill),
          this.life.load(t.life),
          (this.name = t.name),
          (this.particles = ei(t.particles, (t) => je({}, t))),
          this.rate.load(t.rate),
          this.shape.load(t.shape),
          void 0 !== t.position &&
            ((this.position = {}),
            void 0 !== t.position.x && (this.position.x = ue(t.position.x)),
            void 0 !== t.position.y && (this.position.y = ue(t.position.y))),
          void 0 !== t.spawnColor &&
            (void 0 === this.spawnColor && (this.spawnColor = new Os()),
            this.spawnColor.load(t.spawnColor)),
          void 0 !== t.startCount && (this.startCount = t.startCount));
      }
    }
    var Mn;
    !(function (t) {
      t.emitter = "emitter";
    })(Mn || (Mn = {}));
    function Pn(t, e) {
      t.color ? (t.color.value = e) : (t.color = { value: e });
    }
    class Cn {
      constructor(t, e, i, s, o) {
        (this.emitters = e),
          (this.container = i),
          (this._destroy = () => {
            this._mutationObserver?.disconnect(),
              (this._mutationObserver = void 0),
              this._resizeObserver?.disconnect(),
              (this._resizeObserver = void 0),
              this.emitters.removeEmitter(this),
              this._engine.dispatchEvent("emitterDestroyed", {
                container: this.container,
                data: { emitter: this },
              });
          }),
          (this._prepareToDie = () => {
            if (this._paused) return;
            const t =
              void 0 !== this.options.life?.duration
                ? le(this.options.life.duration)
                : void 0;
            this.container.retina.reduceFactor &&
              (this._lifeCount > 0 || this._immortal) &&
              void 0 !== t &&
              t > 0 &&
              (this._duration = t * y);
          }),
          (this._setColorAnimation = (t, e, i, s = 1) => {
            const o = this.container;
            if (!t.enable) return e;
            const n = ce(t.offset),
              a = (le(this.options.rate.delay) * y) / o.retina.reduceFactor;
            return (e + (le(t.speed ?? 0) * o.fpsLimit) / a + n * s) % i;
          }),
          (this._engine = t),
          (this._currentDuration = 0),
          (this._currentEmitDelay = 0),
          (this._currentSpawnDelay = 0),
          (this._initialPosition = o),
          s instanceof zn
            ? (this.options = s)
            : ((this.options = new zn()), this.options.load(s)),
          (this._spawnDelay =
            (le(this.options.life.delay ?? 0) * y) /
            this.container.retina.reduceFactor),
          (this.position = this._initialPosition ?? this._calcPosition()),
          (this.name = this.options.name),
          (this.fill = this.options.fill),
          (this._firstSpawn = !this.options.life.wait),
          (this._startParticlesAdded = !1);
        let n = je({}, this.options.particles);
        if (
          ((n ??= {}),
          (n.move ??= {}),
          (n.move.direction ??= this.options.direction),
          this.options.spawnColor &&
            (this.spawnColor = Oi(this._engine, this.options.spawnColor)),
          (this._paused = !this.options.autoPlay),
          (this._particlesOptions = n),
          (this._size = this._calcSize()),
          (this.size = ri(this._size, this.container.canvas.size)),
          (this._lifeCount = this.options.life.count ?? -1),
          (this._immortal = this._lifeCount <= 0),
          this.options.domId)
        ) {
          const t = document.getElementById(this.options.domId);
          t &&
            ((this._mutationObserver = new MutationObserver(() => {
              this.resize();
            })),
            (this._resizeObserver = new ResizeObserver(() => {
              this.resize();
            })),
            this._mutationObserver.observe(t, {
              attributes: !0,
              attributeFilter: ["style", "width", "height"],
            }),
            this._resizeObserver.observe(t));
        }
        const a = this.options.shape,
          r = this._engine.emitterShapeManager?.getShapeGenerator(a.type);
        r &&
          (this._shape = r.generate(
            this.position,
            this.size,
            this.fill,
            a.options
          )),
          this._engine.dispatchEvent("emitterCreated", {
            container: i,
            data: { emitter: this },
          }),
          this.play();
      }
      externalPause() {
        (this._paused = !0), this.pause();
      }
      externalPlay() {
        (this._paused = !1), this.play();
      }
      async init() {
        await this._shape?.init();
      }
      pause() {
        this._paused || delete this._emitDelay;
      }
      play() {
        if (
          !this._paused &&
          this.container.retina.reduceFactor &&
          (this._lifeCount > 0 || this._immortal || !this.options.life.count) &&
          (this._firstSpawn ||
            this._currentSpawnDelay >= (this._spawnDelay ?? 0))
        ) {
          if (void 0 === this._emitDelay) {
            const t = le(this.options.rate.delay);
            this._emitDelay = (t * y) / this.container.retina.reduceFactor;
          }
          (this._lifeCount > 0 || this._immortal) && this._prepareToDie();
        }
      }
      resize() {
        const t = this._initialPosition;
        (this.position =
          t && Ge(t, this.container.canvas.size, Jt.origin)
            ? t
            : this._calcPosition()),
          (this._size = this._calcSize()),
          (this.size = ri(this._size, this.container.canvas.size)),
          this._shape?.resize(this.position, this.size);
      }
      update(t) {
        this._paused ||
          (this._firstSpawn &&
            ((this._firstSpawn = !1),
            (this._currentSpawnDelay = this._spawnDelay ?? 0),
            (this._currentEmitDelay = this._emitDelay ?? 0)),
          this._startParticlesAdded ||
            ((this._startParticlesAdded = !0),
            this._emitParticles(this.options.startCount)),
          void 0 !== this._duration &&
            ((this._currentDuration += t.value),
            this._currentDuration >= this._duration &&
              (this.pause(),
              void 0 !== this._spawnDelay && delete this._spawnDelay,
              this._immortal || this._lifeCount--,
              this._lifeCount > 0 || this._immortal
                ? ((this.position = this._calcPosition()),
                  this._shape?.resize(this.position, this.size),
                  (this._spawnDelay =
                    (le(this.options.life.delay ?? 0) * y) /
                    this.container.retina.reduceFactor))
                : this._destroy(),
              (this._currentDuration -= this._duration),
              delete this._duration)),
          void 0 !== this._spawnDelay &&
            ((this._currentSpawnDelay += t.value),
            this._currentSpawnDelay >= this._spawnDelay &&
              (this._engine.dispatchEvent("emitterPlay", {
                container: this.container,
              }),
              this.play(),
              (this._currentSpawnDelay -= this._currentSpawnDelay),
              delete this._spawnDelay)),
          void 0 !== this._emitDelay &&
            ((this._currentEmitDelay += t.value),
            this._currentEmitDelay >= this._emitDelay &&
              (this._emit(), (this._currentEmitDelay -= this._emitDelay))));
      }
      _calcPosition() {
        if (this.options.domId) {
          const t = document.getElementById(this.options.domId);
          if (t) {
            const e = t.getBoundingClientRect(),
              i = this.container.retina.pixelRatio;
            return {
              x: (e.x + 0.5 * e.width) * i,
              y: (e.y + 0.5 * e.height) * i,
            };
          }
        }
        return be({
          size: this.container.canvas.size,
          position: this.options.position,
        });
      }
      _calcSize() {
        const t = this.container;
        if (this.options.domId) {
          const e = document.getElementById(this.options.domId);
          if (e) {
            const i = e.getBoundingClientRect();
            return {
              width: i.width * t.retina.pixelRatio,
              height: i.height * t.retina.pixelRatio,
              mode: Se.precise,
            };
          }
        }
        return (
          this.options.size ??
          (() => {
            const t = new xn();
            return t.load({ height: 0, mode: Se.percent, width: 0 }), t;
          })()
        );
      }
      _emit() {
        if (this._paused) return;
        const t = le(this.options.rate.quantity);
        this._emitParticles(t);
      }
      _emitParticles(t) {
        const e = ii(this._particlesOptions);
        for (let i = 0; i < t; i++) {
          const t = je({}, e);
          if (this.spawnColor) {
            const e = this.options.spawnColor?.animation;
            if (e) {
              const t = { h: 360, s: 100, l: 100 },
                i = 3.6;
              (this.spawnColor.h = this._setColorAnimation(
                e.h,
                this.spawnColor.h,
                t.h,
                i
              )),
                (this.spawnColor.s = this._setColorAnimation(
                  e.s,
                  this.spawnColor.s,
                  t.s
                )),
                (this.spawnColor.l = this._setColorAnimation(
                  e.l,
                  this.spawnColor.l,
                  t.l
                ));
            }
            Pn(t, this.spawnColor);
          }
          const i = this.options.shape;
          let s = this.position;
          if (this._shape) {
            const e = this._shape.randomPosition();
            if (e) {
              s = e.position;
              const o = i.replace;
              o.color && e.color && Pn(t, e.color),
                o.opacity &&
                  (t.opacity
                    ? (t.opacity.value = e.opacity)
                    : (t.opacity = { value: e.opacity }));
            } else s = null;
          }
          s && this.container.particles.addParticle(s, t);
        }
      }
    }
    class On {
      constructor(t, e) {
        (this.container = e),
          (this._engine = t),
          (this.array = []),
          (this.emitters = []),
          (this.interactivityEmitters = {
            random: { count: 1, enable: !1 },
            value: [],
          });
        (e.getEmitter = (t) =>
          void 0 === t || $t(t)
            ? this.array[t ?? 0]
            : this.array.find((e) => e.name === t)),
          (e.addEmitter = async (t, e) => this.addEmitter(t, e)),
          (e.removeEmitter = (t) => {
            const i = e.getEmitter(t);
            i && this.removeEmitter(i);
          }),
          (e.playEmitter = (t) => {
            const i = e.getEmitter(t);
            i && i.externalPlay();
          }),
          (e.pauseEmitter = (t) => {
            const i = e.getEmitter(t);
            i && i.externalPause();
          });
      }
      async addEmitter(t, e) {
        const i = new zn();
        i.load(t);
        const s = new Cn(this._engine, this, this.container, i, e);
        return await s.init(), this.array.push(s), s;
      }
      handleClickMode(t) {
        const e = this.emitters,
          i = this.interactivityEmitters;
        if (t !== Mn.emitter) return;
        let s;
        if (i && Xt(i.value)) {
          const t = 0;
          if (i.value.length > t && i.random.enable) {
            s = [];
            const t = [];
            for (let e = 0; e < i.random.count; e++) {
              const o = He(i.value);
              t.includes(o) && t.length < i.value.length
                ? e--
                : (t.push(o), s.push(qe(i.value, o)));
            }
          } else s = i.value;
        } else s = i?.value;
        const o = s ?? e,
          n = this.container.interactivity.mouse.clickPosition;
        ei(o, async (t) => {
          await this.addEmitter(t, n);
        });
      }
      async init() {
        if (
          ((this.emitters = this.container.actualOptions.emitters),
          (this.interactivityEmitters =
            this.container.actualOptions.interactivity.modes.emitters),
          this.emitters)
        )
          if (Xt(this.emitters))
            for (const t of this.emitters) await this.addEmitter(t);
          else await this.addEmitter(this.emitters);
      }
      pause() {
        for (const t of this.array) t.pause();
      }
      play() {
        for (const t of this.array) t.play();
      }
      removeEmitter(t) {
        const e = this.array.indexOf(t);
        e >= 0 && this.array.splice(e, 1);
      }
      resize() {
        for (const t of this.array) t.resize();
      }
      stop() {
        this.array = [];
      }
      update(t) {
        for (const e of this.array) e.update(t);
      }
    }
    class kn {
      constructor(t) {
        (this._engine = t), (this.id = "emitters");
      }
      getPlugin(t) {
        return Promise.resolve(new On(this._engine, t));
      }
      loadOptions(t, e) {
        if (!this.needsPlugin(t) && !this.needsPlugin(e)) return;
        e?.emitters &&
          (t.emitters = ei(e.emitters, (t) => {
            const e = new zn();
            return e.load(t), e;
          }));
        const i = e?.interactivity?.modes?.emitters;
        if (i)
          if (Xt(i))
            t.interactivity.modes.emitters = {
              random: { count: 1, enable: !0 },
              value: i.map((t) => {
                const e = new zn();
                return e.load(t), e;
              }),
            };
          else {
            const e = i;
            if (void 0 !== e.value) {
              const i = 1;
              if (Xt(e.value))
                t.interactivity.modes.emitters = {
                  random: {
                    count: e.random.count ?? i,
                    enable: e.random.enable ?? !1,
                  },
                  value: e.value.map((t) => {
                    const e = new zn();
                    return e.load(t), e;
                  }),
                };
              else {
                const s = new zn();
                s.load(e.value),
                  (t.interactivity.modes.emitters = {
                    random: {
                      count: e.random.count ?? i,
                      enable: e.random.enable ?? !1,
                    },
                    value: s,
                  });
              }
            } else {
              (t.interactivity.modes.emitters = {
                random: { count: 1, enable: !1 },
                value: new zn(),
              }).value.load(i);
            }
          }
      }
      needsPlugin(t) {
        if (!t) return !1;
        const e = t.emitters;
        return (
          (Xt(e) && !!e.length) ||
          void 0 !== e ||
          (!!t.interactivity?.events?.onClick?.mode &&
            Ue(Mn.emitter, t.interactivity.events.onClick.mode))
        );
      }
    }
    const Sn = new Map();
    class Dn {
      constructor(t) {
        this._engine = t;
      }
      addShapeGenerator(t, e) {
        this.getShapeGenerator(t) || Sn.set(t, e);
      }
      getShapeGenerator(t) {
        return Sn.get(t);
      }
      getSupportedShapeGenerators() {
        return Sn.keys();
      }
    }
    class Rn {
      constructor(t, e, i, s) {
        (this.position = t),
          (this.size = e),
          (this.fill = i),
          (this.options = s);
      }
      resize(t, e) {
        (this.position = t), (this.size = e);
      }
    }
    var En;
    function Tn(t, e) {
      return t + e * (ie() - v);
    }
    !(function (t) {
      (t[(t.TopLeft = 0)] = "TopLeft"),
        (t[(t.TopRight = 1)] = "TopRight"),
        (t[(t.BottomRight = 2)] = "BottomRight"),
        (t[(t.BottomLeft = 3)] = "BottomLeft");
    })(En || (En = {}));
    class In extends Rn {
      constructor(t, e, i, s) {
        super(t, e, i, s);
      }
      async init() {}
      randomPosition() {
        const t = this.fill,
          e = this.position,
          i = this.size;
        if (t)
          return { position: { x: Tn(e.x, i.width), y: Tn(e.y, i.height) } };
        {
          const t = i.width * v,
            s = i.height * v,
            o = Math.floor(4 * ie()),
            n = (ie() - v) * x;
          switch (o) {
            case En.TopLeft:
              return { position: { x: e.x + n * t, y: e.y - s } };
            case En.TopRight:
              return { position: { x: e.x - t, y: e.y + n * s } };
            case En.BottomRight:
              return { position: { x: e.x + n * t, y: e.y + s } };
            case En.BottomLeft:
            default:
              return { position: { x: e.x + t, y: e.y + n * s } };
          }
        }
      }
    }
    class Ln {
      generate(t, e, i, s) {
        return new In(t, e, i, s);
      }
    }
    class Fn extends Ds {
      constructor() {
        super(), (this.sync = !1);
      }
      load(t) {
        Yt(t) || (super.load(t), void 0 !== t.sync && (this.sync = t.sync));
      }
    }
    class An extends Ds {
      constructor() {
        super(), (this.sync = !1);
      }
      load(t) {
        Yt(t) || (super.load(t), void 0 !== t.sync && (this.sync = t.sync));
      }
    }
    class Vn {
      constructor() {
        (this.count = 0), (this.delay = new Fn()), (this.duration = new An());
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.count && (this.count = t.count),
          this.delay.load(t.delay),
          this.duration.load(t.duration));
      }
    }
    class Bn {
      constructor(t) {
        this.container = t;
      }
      init(t) {
        const e = this.container,
          i = t.options.life;
        i &&
          ((t.life = {
            delay: e.retina.reduceFactor
              ? ((le(i.delay.value) * (i.delay.sync ? 1 : ie())) /
                  e.retina.reduceFactor) *
                y
              : 0,
            delayTime: 0,
            duration: e.retina.reduceFactor
              ? ((le(i.duration.value) * (i.duration.sync ? 1 : ie())) /
                  e.retina.reduceFactor) *
                y
              : 0,
            time: 0,
            count: i.count,
          }),
          t.life.duration <= 0 && (t.life.duration = -1),
          t.life.count <= 0 && (t.life.count = -1),
          t.life && (t.spawning = t.life.delay > 0));
      }
      isEnabled(t) {
        return !t.destroyed;
      }
      loadOptions(t, ...e) {
        t.life || (t.life = new Vn());
        for (const i of e) t.life.load(i?.life);
      }
      update(t, e) {
        this.isEnabled(t) &&
          t.life &&
          (function (t, e, i) {
            if (!t.life) return;
            const s = t.life;
            let o = !1;
            if (t.spawning) {
              if (((s.delayTime += e.value), !(s.delayTime >= t.life.delay)))
                return;
              (o = !0), (t.spawning = !1), (s.delayTime = 0), (s.time = 0);
            }
            if (-1 === s.duration) return;
            if (t.spawning) return;
            if ((o ? (s.time = 0) : (s.time += e.value), s.time < s.duration))
              return;
            if (
              ((s.time = 0),
              t.life.count > 0 && t.life.count--,
              0 === t.life.count)
            )
              return void t.destroy();
            const n = ue(0, i.width),
              a = ue(0, i.width);
            (t.position.x = ce(n)),
              (t.position.y = ce(a)),
              (t.spawning = !0),
              (s.delayTime = 0),
              (s.time = 0),
              t.reset();
            const r = t.options.life;
            r &&
              ((s.delay = le(r.delay.value) * y),
              (s.duration = le(r.duration.value) * y));
          })(t, e, this.container.canvas.size);
      }
    }
    class Un {
      constructor() {
        (this.enable = !1),
          (this.speed = 0),
          (this.decay = 0),
          (this.sync = !1);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.enable && (this.enable = t.enable),
          void 0 !== t.speed && (this.speed = ue(t.speed)),
          void 0 !== t.decay && (this.decay = ue(t.decay)),
          void 0 !== t.sync && (this.sync = t.sync));
      }
    }
    class Wn extends Ds {
      constructor() {
        super(),
          (this.animation = new Un()),
          (this.direction = ko.clockwise),
          (this.path = !1),
          (this.value = 0);
      }
      load(t) {
        Yt(t) ||
          (super.load(t),
          void 0 !== t.direction && (this.direction = t.direction),
          this.animation.load(t.animation),
          void 0 !== t.path && (this.path = t.path));
      }
    }
    const Hn = 2 * Math.PI;
    class qn {
      constructor(t) {
        this.container = t;
      }
      init(t) {
        const e = t.options.rotate;
        if (!e) return;
        (t.rotate = {
          enable: e.animation.enable,
          value: me(le(e.value)),
          min: 0,
          max: Hn,
        }),
          (t.pathRotation = e.path);
        let i = e.direction;
        if (i === ko.random) {
          i = Math.floor(2 * ie()) > 0 ? ko.counterClockwise : ko.clockwise;
        }
        switch (i) {
          case ko.counterClockwise:
          case "counterClockwise":
            t.rotate.status = Ce.decreasing;
            break;
          case ko.clockwise:
            t.rotate.status = Ce.increasing;
        }
        const s = e.animation;
        s.enable &&
          ((t.rotate.decay = 1 - le(s.decay)),
          (t.rotate.velocity =
            (le(s.speed) / 360) * this.container.retina.reduceFactor),
          s.sync || (t.rotate.velocity *= ie())),
          (t.rotation = t.rotate.value);
      }
      isEnabled(t) {
        const e = t.options.rotate;
        return (
          !!e &&
          !t.destroyed &&
          !t.spawning &&
          (!!e.value || e.animation.enable || e.path)
        );
      }
      loadOptions(t, ...e) {
        t.rotate || (t.rotate = new Wn());
        for (const i of e) t.rotate.load(i?.rotate);
      }
      update(t, e) {
        this.isEnabled(t) &&
          ((t.isRotating = !!t.rotate),
          t.rotate &&
            (ci(t, t.rotate, !1, Oe.none, e), (t.rotation = t.rotate.value)));
      }
    }
    class Gn {
      constructor() {
        (this.loop = !1), (this.source = "");
      }
      load(t) {
        Yt(t) ||
          (Qt(t)
            ? (void 0 !== t.loop && (this.loop = t.loop),
              void 0 !== t.source && (this.source = t.source))
            : (this.source = t));
      }
    }
    class Nn {
      constructor() {
        (this.duration = 500), (this.value = []);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.duration && (this.duration = t.duration),
          void 0 !== t.value && (this.value = t.value));
      }
    }
    class $n {
      constructor() {
        (this.loop = !1), (this.melodies = []), (this.notes = []);
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.loop && (this.loop = t.loop),
          void 0 !== t.melodies &&
            (this.melodies = t.melodies.map((t) => {
              const e = new $n();
              return e.load(t), e;
            })),
          void 0 !== t.notes &&
            (this.notes = t.notes.map((t) => {
              const e = new Nn();
              return e.load(t), e;
            })));
      }
    }
    class jn {
      constructor() {
        (this.event = []), (this.notes = []);
      }
      load(t) {
        if (
          !Yt(t) &&
          (void 0 !== t.event && (this.event = t.event),
          void 0 !== t.audio &&
            (Xt(t.audio)
              ? (this.audio = t.audio.map((t) => {
                  const e = new Gn();
                  return e.load(t), e;
                }))
              : ((this.audio = new Gn()), this.audio.load(t.audio))),
          void 0 !== t.notes &&
            (this.notes = t.notes.map((t) => {
              const e = new Nn();
              return e.load(t), e;
            })),
          void 0 !== t.melodies &&
            (this.melodies = t.melodies.map((t) => {
              const e = new $n();
              return e.load(t), e;
            })),
          t.filter)
        )
          if (Nt(t.filter)) {
            const e = window[t.filter];
            jt(e) && (this.filter = e);
          } else this.filter = t.filter;
      }
    }
    class Qn {
      constructor() {
        (this.width = 24), (this.height = 24), (this.style = "");
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.path && (this.path = t.path),
          void 0 !== t.svg && (this.svg = t.svg),
          void 0 !== t.width && (this.width = t.width),
          void 0 !== t.height && (this.height = t.height));
      }
    }
    class Xn {
      constructor() {
        (this.mute = new Qn()),
          (this.unmute = new Qn()),
          (this.volumeDown = new Qn()),
          (this.volumeUp = new Qn()),
          (this.enable = !1),
          (this.mute.svg =
            '<?xml version="1.0"?>\n<svg baseProfile="tiny" height="24px" version="1.2" viewBox="0 0 24 24" width="24px"\n    xml:space="preserve" xmlns="http://www.w3.org/2000/svg"\n    xmlns:xlink="http://www.w3.org/1999/xlink">\n    <g id="Layer_1">\n        <path fill="#fff" d="M19.707,5.293c-0.391-0.391-1.023-0.391-1.414,0l-1.551,1.551c-0.345-0.688-0.987-1.02-1.604-1.02c-0.449,0-0.905,0.152-1.356,0.453l-2.672,1.781C10.357,8.561,8.904,9,8,9c-1.654,0-3,1.346-3,3v2c0,1.237,0.754,2.302,1.826,2.76l-1.533,1.533c-0.391,0.391-0.391,1.023,0,1.414C5.488,19.902,5.744,20,6,20s0.512-0.098,0.707-0.293l2.527-2.527c0.697,0.174,1.416,0.455,1.875,0.762l2.672,1.781c0.451,0.301,0.907,0.453,1.356,0.453C16.035,20.176,17,19.495,17,18V9.414l2.707-2.707C20.098,6.316,20.098,5.684,19.707,5.293z M14.891,7.941c0.038-0.025,0.073-0.046,0.104-0.062C14.998,7.914,15,7.954,15,8v1.293l-2,2V9.202L14.891,7.941z M7,12c0-0.552,0.448-1,1-1c1.211,0,2.907-0.495,4-1.146v2.439l-2.83,2.83C8.757,15.046,8.356,15,8,15c-0.552,0-1-0.448-1-1V12z M10.301,15.406L12,13.707v2.439C11.519,15.859,10.925,15.604,10.301,15.406z M14.994,18.12c-0.03-0.016-0.065-0.036-0.104-0.062L13,16.798v-4.091l2-2V18C15,18.046,14.998,18.086,14.994,18.12z"/>\n    </g>\n</svg>'),
          (this.unmute.svg =
            '<?xml version="1.0"?>\n<svg baseProfile="tiny" height="24px" version="1.2" viewBox="0 0 24 24" width="24px"\n    xml:space="preserve" xmlns="http://www.w3.org/2000/svg"\n    xmlns:xlink="http://www.w3.org/1999/xlink">\n    <g id="Layer_1">\n        <path fill="#fff" d="M17.138,5.824c-0.449,0-0.905,0.152-1.356,0.453l-2.672,1.781C12.357,8.561,10.904,9,10,9c-1.654,0-3,1.346-3,3v2c0,1.654,1.346,3,3,3c0.904,0,2.357,0.439,3.109,0.941l2.672,1.781c0.451,0.301,0.907,0.453,1.356,0.453C18.035,20.176,19,19.495,19,18V8C19,6.505,18.035,5.824,17.138,5.824z M14,16.146C12.907,15.495,11.211,15,10,15c-0.552,0-1-0.448-1-1v-2c0-0.552,0.448-1,1-1c1.211,0,2.907-0.495,4-1.146V16.146z M17,18c0,0.046-0.002,0.086-0.006,0.12c-0.03-0.016-0.065-0.036-0.104-0.062L15,16.798V9.202l1.891-1.261c0.038-0.025,0.073-0.046,0.104-0.062C16.998,7.914,17,7.954,17,8V18z"/>\n    </g>\n</svg>'),
          (this.volumeDown.svg =
            '<?xml version="1.0"?>\n<svg baseProfile="tiny" height="24px" version="1.2" viewBox="0 0 24 24" width="24px"\n    xml:space="preserve" xmlns="http://www.w3.org/2000/svg"\n    xmlns:xlink="http://www.w3.org/1999/xlink">\n    <g id="Layer_1">\n        <path fill="#fff" d="M15.138,5.824c-0.449,0-0.905,0.152-1.356,0.453l-2.672,1.781C10.357,8.561,8.904,9,8,9c-1.654,0-3,1.346-3,3v2c0,1.654,1.346,3,3,3c0.904,0,2.357,0.439,3.109,0.941l2.672,1.781c0.451,0.301,0.907,0.453,1.356,0.453C16.035,20.176,17,19.495,17,18V8C17,6.505,16.035,5.824,15.138,5.824z M8,15c-0.552,0-1-0.448-1-1v-2c0-0.552,0.448-1,1-1c1.211,0,2.907-0.495,4-1.146v6.293C10.907,15.495,9.211,15,8,15z M15,18c0,0.046-0.002,0.086-0.006,0.12c-0.03-0.016-0.065-0.036-0.104-0.062L13,16.798V9.202l1.891-1.261c0.038-0.025,0.073-0.046,0.104-0.062C14.998,7.914,15,7.954,15,8V18z"/>\n        <path fill="#fff" d="M18.292,10.294c-0.39,0.391-0.39,1.023,0.002,1.414c0.345,0.345,0.535,0.803,0.535,1.291c0,0.489-0.19,0.948-0.536,1.294c-0.391,0.39-0.391,1.023,0,1.414C18.488,15.902,18.744,16,19,16s0.512-0.098,0.707-0.293c0.724-0.723,1.122-1.685,1.122-2.708s-0.398-1.984-1.123-2.707C19.317,9.903,18.683,9.901,18.292,10.294z"/>\n    </g>\n</svg>'),
          (this.volumeUp.svg =
            '<?xml version="1.0"?>\n<svg baseProfile="tiny" height="24px" version="1.2" viewBox="0 0 24 24" width="24px"\n    xml:space="preserve" xmlns="http://www.w3.org/2000/svg"\n    xmlns:xlink="http://www.w3.org/1999/xlink">\n    <g id="Layer_1">\n        <path fill="#fff" d="M16.706,10.292c-0.389-0.389-1.023-0.391-1.414,0.002c-0.39,0.391-0.39,1.023,0.002,1.414c0.345,0.345,0.535,0.803,0.535,1.291c0,0.489-0.19,0.948-0.536,1.294c-0.391,0.39-0.391,1.023,0,1.414C15.488,15.902,15.744,16,16,16s0.512-0.098,0.707-0.293c0.724-0.723,1.122-1.685,1.122-2.708S17.431,11.015,16.706,10.292z"/>\n        <path fill="#fff" d="M18.706,8.292c-0.391-0.389-1.023-0.39-1.414,0.002c-0.39,0.391-0.39,1.024,0.002,1.414c0.879,0.877,1.363,2.044,1.364,3.287c0.001,1.246-0.484,2.417-1.365,3.298c-0.391,0.391-0.391,1.023,0,1.414C17.488,17.902,17.744,18,18,18s0.512-0.098,0.707-0.293c1.259-1.259,1.952-2.933,1.951-4.713C20.657,11.217,19.964,9.547,18.706,8.292z"/>\n        <path fill="#fff" d="M20.706,6.292c-0.391-0.389-1.023-0.39-1.414,0.002c-0.39,0.391-0.39,1.024,0.002,1.414c1.412,1.409,2.191,3.285,2.192,5.284c0.002,2.002-0.777,3.885-2.193,5.301c-0.391,0.391-0.391,1.023,0,1.414C19.488,19.902,19.744,20,20,20s0.512-0.098,0.707-0.293c1.794-1.794,2.781-4.18,2.779-6.717C23.485,10.457,22.497,8.078,20.706,6.292z"/>\n        <path fill="#fff" d="M12.138,5.824c-0.449,0-0.905,0.152-1.356,0.453L8.109,8.059C7.357,8.561,5.904,9,5,9c-1.654,0-3,1.346-3,3v2c0,1.654,1.346,3,3,3c0.904,0,2.357,0.439,3.109,0.941l2.672,1.781c0.451,0.301,0.907,0.453,1.356,0.453C13.035,20.176,14,19.495,14,18V8C14,6.505,13.035,5.824,12.138,5.824z M5,15c-0.552,0-1-0.448-1-1v-2c0-0.552,0.448-1,1-1c1.211,0,2.907-0.495,4-1.146v6.293C7.907,15.495,6.211,15,5,15z M12,18c0,0.046-0.002,0.086-0.006,0.12c-0.03-0.016-0.065-0.036-0.104-0.062L10,16.798V9.202l1.891-1.261c0.038-0.025,0.073-0.046,0.104-0.062C11.998,7.914,12,7.954,12,8V18z"/>\n    </g>\n</svg>');
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.enable && (this.enable = t.enable),
          this.mute.load(t.mute),
          this.unmute.load(t.unmute),
          this.volumeDown.load(t.volumeDown),
          this.volumeUp.load(t.volumeUp));
      }
    }
    class Yn {
      constructor() {
        (this.value = 100), (this.max = 100), (this.min = 0), (this.step = 10);
      }
      load(t) {
        Yt(t) ||
          (Qt(t)
            ? (void 0 !== t.max && (this.max = t.max),
              void 0 !== t.min && (this.min = t.min),
              void 0 !== t.step && (this.step = t.step),
              void 0 !== t.value && (this.value = t.value))
            : (this.value = t));
      }
    }
    class Zn {
      constructor() {
        (this.autoPlay = !0),
          (this.enable = !1),
          (this.events = []),
          (this.icons = new Xn()),
          (this.volume = new Yn());
      }
      load(t) {
        Yt(t) ||
          (void 0 !== t.autoPlay && (this.autoPlay = t.autoPlay),
          void 0 !== t.enable && (this.enable = t.enable),
          void 0 !== t.events &&
            (this.events = t.events.map((t) => {
              const e = new jn();
              return e.load(t), e;
            })),
          this.icons.load(t.icons),
          void 0 !== t.volume && this.volume.load(t.volume));
      }
    }
    var Jn, Kn;
    !(function (t) {
      (t.mute = "soundsMuted"), (t.unmute = "soundsUnmuted");
    })(Jn || (Jn = {})),
      (function (t) {
        (t.Block = "block"), (t.None = "none");
      })(Kn || (Kn = {}));
    const ta = new Map();
    function ea(t) {
      const e = /(([A-G]b?)(\d))|pause/i.exec(t);
      if (!e?.length) return;
      const i = e[2] || e[0],
        s = ta.get(i);
      return s ? s[parseInt(e[3] || "0")] : void 0;
    }
    ta.set(
      "C",
      [16.35, 32.7, 65.41, 130.81, 261.63, 523.25, 1046.5, 2093, 4186.01]
    ),
      ta.set(
        "Db",
        [17.32, 34.65, 69.3, 138.59, 277.18, 554.37, 1108.73, 2217.46, 4434.92]
      ),
      ta.set(
        "D",
        [18.35, 36.71, 73.42, 146.83, 293.66, 587.33, 1174.66, 2349.32, 4698.63]
      ),
      ta.set(
        "Eb",
        [19.45, 38.89, 77.78, 155.56, 311.13, 622.25, 1244.51, 2489.02, 4978.03]
      ),
      ta.set(
        "E",
        [20.6, 41.2, 82.41, 164.81, 329.63, 659.25, 1318.51, 2637.02, 5274.04]
      ),
      ta.set(
        "F",
        [21.83, 43.65, 87.31, 174.61, 349.23, 698.46, 1396.91, 2793.83, 5587.65]
      ),
      ta.set(
        "Gb",
        [23.12, 46.25, 92.5, 185, 369.99, 739.99, 1479.98, 2959.96, 5919.91]
      ),
      ta.set("G", [24.5, 49, 98, 196, 392, 783.99, 1567.98, 3135.96, 6271.93]),
      ta.set(
        "Ab",
        [25.96, 51.91, 103.83, 207.65, 415.3, 830.61, 1661.22, 3322.44, 6644.88]
      ),
      ta.set("A", [27.5, 55, 110, 220, 440, 880, 1760, 3520, 7040]),
      ta.set(
        "Bb",
        [
          29.14, 58.27, 116.54, 233.08, 466.16, 932.33, 1864.66, 3729.31,
          7458.62,
        ]
      ),
      ta.set(
        "B",
        [
          30.87, 61.74, 123.47, 246.94, 493.88, 987.77, 1975.53, 3951.07,
          7902.13,
        ]
      ),
      ta.set("pause", [0]);
    let ia = !0;
    const sa = () => ia,
      oa = () => {
        ia = !1;
      },
      na = 1;
    function aa(t) {
      const e = document.createElement("img"),
        {
          clickCb: i,
          container: s,
          display: o,
          iconOptions: n,
          margin: a,
          options: r,
          pos: c,
          rightOffsets: l,
        } = t,
        { width: h, path: d, style: u, svg: p } = n;
      !(function (t, e, i, s, o, n, a, r) {
        (t.style.userSelect = "none"),
          (t.style.webkitUserSelect = "none"),
          (t.style.position = "absolute"),
          (t.style.top = `${e + a}px`),
          (t.style.left = i - a - n + "px"),
          (t.style.display = s),
          (t.style.zIndex = `${o + na}`),
          (t.style.cssText += r);
      })(
        e,
        c.top + a,
        c.right - (a * (l.length + 1) + h + l.reduce((t, e) => t + e, 0)),
        o,
        r.fullScreen.zIndex + na,
        h,
        a,
        u
      ),
        (e.src = d ?? (p ? `data:image/svg+xml;base64,${btoa(p)}` : ""));
      return (
        (s.canvas.element?.parentNode ?? document.body).append(e),
        e.addEventListener("click", () => {
          i();
        }),
        e
      );
    }
    function ra(t) {
      t && t.remove();
    }
    class ca {
      constructor(t, e) {
        (this._addBuffer = (t) => {
          const e = t.createBufferSource();
          return this._audioSources.push(e), e;
        }),
          (this._addOscillator = (t) => {
            const e = t.createOscillator();
            return this._audioSources.push(e), e;
          }),
          (this._initEvents = () => {
            const t = this._container,
              e = t.actualOptions.sounds;
            if (e?.enable && t.canvas.element)
              for (const t of e.events) {
                const e = (i) => {
                  (async () => {
                    const s = t.filter && !t.filter(i);
                    if (this._container !== i.container) return;
                    if (
                      !this._container ||
                      this._container.muted ||
                      this._container.destroyed
                    )
                      return void ei(t.event, (t) => {
                        this._engine.removeEventListener(t, e);
                      });
                    if (s) return;
                    if (t.audio) this._playBuffer(ii(t.audio));
                    else if (t.melodies) {
                      const e = qe(t.melodies);
                      e.melodies.length
                        ? await Promise.allSettled(
                            e.melodies.map((t) =>
                              this._playNote(t.notes, 0, e.loop)
                            )
                          )
                        : await this._playNote(e.notes, 0, e.loop);
                    } else if (t.notes) {
                      const e = qe(t.notes);
                      await this._playNote([e], 0, !1);
                    }
                  })();
                };
                ei(t.event, (t) => {
                  this._engine.addEventListener(t, e);
                });
              }
          }),
          (this._mute = async () => {
            const t = this._container,
              e = this._getAudioContext();
            for (const t of this._audioSources) this._removeAudioSource(t);
            this._gain && this._gain.disconnect(),
              await e.close(),
              (t.audioContext = void 0),
              this._engine.dispatchEvent(Jn.mute, {
                container: this._container,
              });
          }),
          (this._playBuffer = (t) => {
            const e = this._audioMap.get(t.source);
            if (!e) return;
            const i = this._container.audioContext;
            if (!i) return;
            const s = this._addBuffer(i);
            (s.loop = t.loop),
              (s.buffer = e),
              s.connect(this._gain ?? i.destination),
              s.start();
          }),
          (this._playFrequency = async (t, e) => {
            if (!this._gain || this._container.muted) return;
            const i = this._getAudioContext(),
              s = this._addOscillator(i);
            return (
              s.connect(this._gain),
              (s.type = "sine"),
              (s.frequency.value = t),
              s.start(),
              new Promise((t) => {
                setTimeout(() => {
                  this._removeAudioSource(s), t();
                }, e);
              })
            );
          }),
          (this._playMuteSound = () => {
            if (this._container.muted) return;
            const t = this._getAudioContext(),
              e = t.createGain();
            e.connect(t.destination), (e.gain.value = 0);
            const i = t.createOscillator();
            i.connect(e),
              (i.type = "sine"),
              (i.frequency.value = 1),
              i.start(),
              setTimeout(() => {
                i.stop(), i.disconnect(), e.disconnect();
              });
          }),
          (this._playNote = async (t, e, i) => {
            if (this._container.muted) return;
            const s = t[e];
            if (!s) return;
            const o = ei(s.value, async (i, s) => this._playNoteValue(t, e, s));
            await (Xt(o) ? Promise.allSettled(o) : o);
            let n = e + 1;
            i && n >= t.length && (n %= t.length),
              this._container.muted || (await this._playNote(t, n, i));
          }),
          (this._playNoteValue = async (t, e, i) => {
            const s = t[e];
            if (!s) return;
            const o = ii(s.value, i, !0);
            try {
              const t = ea(o);
              if (!$t(t)) return;
              await this._playFrequency(t, s.duration);
            } catch (t) {
              Te().error(t);
            }
          }),
          (this._removeAudioSource = (t) => {
            t.stop(), t.disconnect();
            this._audioSources.splice(this._audioSources.indexOf(t), 1);
          }),
          (this._unmute = () => {
            const t = this._container.actualOptions.sounds;
            if (!t) return;
            const e = this._getAudioContext();
            this._audioSources || (this._audioSources = []);
            const i = e.createGain();
            i.connect(e.destination),
              (i.gain.value = t.volume.value / m),
              (this._gain = i),
              this._initEvents(),
              this._engine.dispatchEvent(Jn.unmute, {
                container: this._container,
              });
          }),
          (this._updateMuteIcons = () => {
            const t = this._container,
              e = t.actualOptions.sounds;
            if (!e?.enable || !e.icons.enable) return;
            const i = this._muteImg,
              s = this._unmuteImg;
            i && (i.style.display = t.muted ? "block" : "none"),
              s && (s.style.display = t.muted ? "none" : "block");
          }),
          (this._updateMuteStatus = async () => {
            const t = this._container,
              e = this._getAudioContext();
            t.muted
              ? (await e?.suspend(), await this._mute())
              : (await e?.resume(), this._unmute(), this._playMuteSound());
          }),
          (this._updateVolume = async () => {
            const t = this._container,
              e = t.actualOptions.sounds;
            if (!e?.enable) return;
            ae(this._volume, e.volume.min, e.volume.max);
            let i = !1;
            this._volume <= 0 && !t.muted
              ? ((this._volume = 0), (t.muted = !0), (i = !0))
              : this._volume > 0 && t.muted && ((t.muted = !1), (i = !0)),
              i && (this._updateMuteIcons(), await this._updateMuteStatus()),
              this._gain?.gain && (this._gain.gain.value = this._volume / m);
          }),
          (this._container = t),
          (this._engine = e),
          (this._volume = 0),
          (this._audioSources = []),
          (this._audioMap = new Map());
      }
      async init() {
        const t = this._container.actualOptions.sounds;
        if (!t?.enable) return;
        if (t.autoPlay && sa()) {
          const t = () => {
              removeEventListener(s, t),
                removeEventListener(c, t),
                oa(),
                this.unmute();
            },
            e = { capture: !0, once: !0 };
          addEventListener(s, t, e), addEventListener(c, t, e);
        }
        this._volume = t.volume.value;
        const e = t.events;
        this._audioMap = new Map();
        for (const t of e) {
          if (!t.audio) continue;
          const e = ei(t.audio, async (t) => {
            const e = await fetch(t.source);
            if (!e.ok) return;
            const i = await e.arrayBuffer(),
              s = this._getAudioContext(),
              o = await s.decodeAudioData(i);
            this._audioMap.set(t.source, o);
          });
          e instanceof Promise ? await e : await Promise.allSettled(e);
        }
      }
      async mute() {
        this._container.muted || (await this.toggleMute());
      }
      async start() {
        const t = this._container,
          e = t.actualOptions,
          i = e.sounds;
        if (!i?.enable || !t.canvas.element) return;
        t.muted = !0;
        const s = t.canvas.element,
          o = { top: s.offsetTop, right: s.offsetLeft + s.offsetWidth },
          { mute: n, unmute: a, volumeDown: r, volumeUp: c } = i.icons,
          l = async () => {
            await this.toggleMute();
          },
          h = i.icons.enable ? Kn.Block : Kn.None;
        (this._muteImg = aa({
          container: t,
          options: e,
          pos: o,
          display: h,
          iconOptions: n,
          margin: 10,
          rightOffsets: [r.width, c.width],
          clickCb: l,
        })),
          (this._unmuteImg = aa({
            container: t,
            options: e,
            pos: o,
            display: Kn.None,
            iconOptions: a,
            margin: 10,
            rightOffsets: [r.width, c.width],
            clickCb: l,
          })),
          (this._volumeDownImg = aa({
            container: t,
            options: e,
            pos: o,
            display: h,
            iconOptions: r,
            margin: 10,
            rightOffsets: [c.width],
            clickCb: async () => {
              await this.volumeDown();
            },
          })),
          (this._volumeUpImg = aa({
            container: t,
            options: e,
            pos: o,
            display: h,
            iconOptions: c,
            margin: 10,
            rightOffsets: [],
            clickCb: async () => {
              await this.volumeUp();
            },
          })),
          !sa() && i.autoPlay && (await this.unmute());
      }
      stop() {
        (this._container.muted = !0),
          (async () => {
            await this._mute(),
              ra(this._muteImg),
              ra(this._unmuteImg),
              ra(this._volumeDownImg),
              ra(this._volumeUpImg);
          })();
      }
      async toggleMute() {
        const t = this._container;
        (t.muted = !t.muted),
          this._updateMuteIcons(),
          await this._updateMuteStatus();
      }
      async unmute() {
        this._container.muted && (await this.toggleMute());
      }
      async volumeDown() {
        const t = this._container,
          e = t.actualOptions.sounds;
        e?.enable &&
          (t.muted && (this._volume = 0),
          (this._volume -= e.volume.step),
          await this._updateVolume());
      }
      async volumeUp() {
        const t = this._container.actualOptions.sounds;
        t?.enable &&
          ((this._volume += t.volume.step), await this._updateVolume());
      }
      _getAudioContext() {
        const t = this._container;
        return (
          t.audioContext || (t.audioContext = new AudioContext()),
          t.audioContext
        );
      }
    }
    const la = () => {
      removeEventListener(s, la), removeEventListener(c, la), oa();
    };
    class ha {
      constructor(t) {
        (this.id = "sounds"), (this._engine = t);
        const e = { capture: !0, once: !0 };
        addEventListener(s, la, e), addEventListener(c, la, e);
      }
      getPlugin(t) {
        return Promise.resolve(new ca(t, this._engine));
      }
      loadOptions(t, e) {
        if (!this.needsPlugin(t) && !this.needsPlugin(e)) return;
        let i = t.sounds;
        void 0 === i?.load && (t.sounds = i = new Zn()), i.load(e?.sounds);
      }
      needsPlugin(t) {
        return t?.sounds?.enable ?? !1;
      }
    }
    const da = { a: 1, b: 0, c: 0, d: 1 };
    class ua {
      draw(t) {
        const { context: e, radius: i, particle: s, transformData: o } = t,
          n = i * x,
          a = s.container.retina.pixelRatio,
          r = s.getPosition(),
          c = s.trail;
        if (!c || !s.trailLength) return;
        const l = s.trailLength + i;
        if (
          (c.push({
            color: e.fillStyle ?? e.strokeStyle,
            position: { x: r.x, y: r.y },
            transformData: { ...t.transformData },
          }),
          c.length < 2)
        )
          return;
        for (; c.length > l; ) c.shift();
        const h = Math.min(c.length, l),
          d = s.container.canvas.size.width + n,
          u = s.container.canvas.size.height + n;
        let p = c[h - 1].position;
        for (let t = h; t > ht; t--) {
          const i = c[t - 1],
            o = i.position,
            r = s.trailTransform ? i.transformData ?? da : da;
          e.setTransform(r.a, r.b, r.c, r.d, o.x, o.y),
            e.beginPath(),
            e.moveTo(p.x - o.x, p.y - o.y);
          const l = { x: (p.x + d) % d, y: (p.y + u) % u };
          if (Math.abs(p.x - o.x) > d * v || Math.abs(p.y - o.y) > u * v) {
            p = o;
            continue;
          }
          e.lineTo(
            Math.abs(p.x - o.x) > d * v ? l.x : g.x,
            Math.abs(p.y - o.y) > u * v ? l.y : g.y
          );
          const f = Math.max((t / h) * n, a, s.trailMinWidth ?? -1),
            m = e.globalAlpha;
          (e.globalAlpha = s.trailFade ? t / h : P),
            (e.lineWidth = s.trailMaxWidth ? Math.min(f, s.trailMaxWidth) : f),
            (e.strokeStyle = i.color),
            e.stroke(),
            (e.globalAlpha = m),
            (p = o);
        }
        e.setTransform(o.a, o.b, o.c, o.d, r.x, r.y);
      }
      particleInit(t, e) {
        e.trail = [];
        const i = e.effectData;
        (e.trailFade = i?.fade ?? !0),
          (e.trailLength = le(i?.length ?? 10) * t.retina.pixelRatio),
          (e.trailMaxWidth = i?.maxWidth
            ? le(i.maxWidth) * t.retina.pixelRatio
            : void 0),
          (e.trailMinWidth = i?.minWidth
            ? le(i.minWidth) * t.retina.pixelRatio
            : void 0),
          (e.trailTransform = i?.transform ?? !1);
      }
    }
    let pa = !1,
      fa = !1;
    const ma = (t) => {
      const e = t.data;
      return (
        "circle" === e.particle.shape &&
        !!e.particle.splitCount &&
        e.particle.splitCount < 2
      );
    };
    class va {
      constructor(t) {
        this._container = t;
      }
      pause() {
        this._container.pause();
      }
      play() {
        this._container.play();
      }
      stop() {
        this._container.stop();
      }
    }
    async function ya(t) {
      if (!pa) {
        if (fa)
          return new Promise((t) => {
            const e = setInterval(() => {
              pa && (clearInterval(e), t());
            }, 100);
          });
        (fa = !0),
          t.checkVersion("3.8.1"),
          await (async function (t, e = !0) {
            t.checkVersion("3.8.1"),
              t.emitterShapeManager || (t.emitterShapeManager = new Dn(t)),
              t.addEmitterShapeGenerator ||
                (t.addEmitterShapeGenerator = (e, i) => {
                  t.emitterShapeManager?.addShapeGenerator(e, i);
                });
            const i = new kn(t);
            await t.addPlugin(i, e);
          })(t, !1),
          await (async function (t, e = !0) {
            const i = t;
            i.checkVersion("3.8.1"),
              i.addEmitterShapeGenerator?.("square", new Ln()),
              await i.refresh(e);
          })(t, !1),
          await (async function (t, e = !0) {
            t.checkVersion("3.8.1"), await t.addPlugin(new ha(t), e);
          })(t, !1),
          await (async function (t, e = !0) {
            t.checkVersion("3.8.1"),
              await t.addParticleUpdater(
                "rotate",
                (t) => Promise.resolve(new qn(t)),
                e
              );
          })(t, !1),
          await (async function (t, e = !0) {
            t.checkVersion("3.8.1"),
              await t.addParticleUpdater(
                "destroy",
                (e) => Promise.resolve(new yn(t, e)),
                e
              );
          })(t, !1),
          await (async function (t, e = !0) {
            t.checkVersion("3.8.1"),
              await t.addParticleUpdater(
                "life",
                async (t) => Promise.resolve(new Bn(t)),
                e
              );
          })(t, !1),
          await (async function (t, e = !0) {
            t.checkVersion("3.8.1"), await t.addEffect("trail", new ua(), e);
          })(t, !1),
          await on(t, !1),
          (fa = !1),
          (pa = !0);
      }
    }
    async function ga(t, e, i) {
      await ya(Ro);
      const s = new Eo();
      s.load(e);
      const o = (function (t, e) {
          return {
            detectRetina: !0,
            background: { color: t.background },
            fullScreen: { enable: !!e },
            fpsLimit: 60,
            emitters: {
              direction: qt.top,
              life: { count: 0, duration: 0.1, delay: 0.1 },
              rate: {
                delay: $t(t.rate)
                  ? 1 / t.rate
                  : { min: 1 / he(t.rate), max: 1 / de(t.rate) },
                quantity: 1,
              },
              size: { width: 100, height: 0 },
              position: { y: 100, x: 50 },
            },
            particles: {
              number: { value: 0 },
              color: { value: "#fff" },
              destroy: {
                mode: "split",
                bounds: { top: ue(t.minHeight) },
                split: {
                  sizeOffset: !1,
                  count: 1,
                  factor: { value: 0.333333 },
                  rate: { value: t.splitCount },
                  colorOffset: { s: t.saturation, l: t.brightness },
                  particles: {
                    color: { value: t.colors },
                    number: { value: 0 },
                    opacity: {
                      value: { min: 0.1, max: 1 },
                      animation: {
                        enable: !0,
                        speed: 1,
                        sync: !1,
                        startValue: De.max,
                        destroy: Oe.min,
                      },
                    },
                    effect: {
                      type: "trail",
                      options: { trail: { length: { min: 5, max: 10 } } },
                    },
                    shape: { type: "circle" },
                    size: {
                      value: { min: 1, max: 2 },
                      animation: {
                        enable: !0,
                        speed: 5,
                        count: 1,
                        sync: !1,
                        startValue: De.min,
                        destroy: Oe.none,
                      },
                    },
                    life: {
                      count: 1,
                      duration: { value: { min: 0.25, max: 0.5 } },
                    },
                    move: {
                      decay: { min: 0.05, max: 0.1 },
                      enable: !0,
                      gravity: {
                        enable: !0,
                        inverse: !1,
                        acceleration: ue(t.gravity),
                      },
                      speed: ue(t.speed),
                      direction: "none",
                      outModes: gi.destroy,
                    },
                  },
                },
              },
              life: { count: 1 },
              effect: {
                type: "trail",
                options: {
                  trail: {
                    length: { min: 10, max: 30 },
                    minWidth: 1,
                    maxWidth: 1,
                  },
                },
              },
              shape: { type: "circle" },
              size: { value: 1 },
              opacity: { value: 0.5 },
              rotate: { path: !0 },
              move: {
                enable: !0,
                gravity: {
                  acceleration: 15,
                  enable: !0,
                  inverse: !0,
                  maxSpeed: 100,
                },
                speed: { min: 10, max: 20 },
                outModes: { default: gi.destroy, top: gi.none },
              },
            },
            sounds: {
              enable: t.sounds,
              events: [
                {
                  event: pi.particleRemoved,
                  filter: ma,
                  audio: [
                    "https://particles.js.org/audio/explosion0.mp3",
                    "https://particles.js.org/audio/explosion1.mp3",
                    "https://particles.js.org/audio/explosion2.mp3",
                  ],
                },
              ],
              volume: 50,
            },
          };
        })(s, i),
        n = await Ro.load({ id: t, element: i, options: o });
      if (n) return new va(n);
    }
    async function wa(t, e) {
      let i, s;
      return (
        Nt(t) ? ((i = t), (s = e ?? {})) : ((i = "fireworks"), (s = t ?? {})),
        ga(i, s)
      );
    }
    return (
      (wa.create = async (t, e) => ga(t.id ?? "fireworks", e ?? {}, t)),
      (wa.init = async () => {
        await ya(Ro);
      }),
      (wa.version = "3.8.1"),
      Le() || (window.fireworks = wa),
      e
    );
  })()
);
